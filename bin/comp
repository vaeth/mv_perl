#!/usr/bin/perl

sub version { '$Revision: 1.2 $ '=~ /Revision:\s([^\s]*)/;
  print "comp v$1 by Martin VÃ¤th\n"
   .    "martin\@mvath.de\n" ; exit 0 }

$0 =~ /([^\/]*)$/; $comp=$1;
sub help { $0 =~ /(\w*)(\.\w*)?$/; print <<"EOHELP";
Usage: $comp [Option] ... [Option] Dir/\"Mask\" Dir/\"Mask\" ... LastDir/\"Mask\"
  or : $comp [Option] ... [Option] Dir/\"Mask\"
Compares the Dirs/files given by the first argument with LastDir/Mask.
In the second form, LastDir/Mask defaults to \"\"
The files are always compared binary; also date/attributes/... are compared.
Do not forget \"...\" around Mask, since directories are considered different
than single files (in directories it is recursed). Options are:
-d:  Do *not* compare date/attributes/... of highest directories.
-r:  Do *not* compare recursively (except for one step in directory arguments)
-c:  Compare only filesizes and attributes, not the contents of the files
-t:  Do not compare time/date for directories (useful for DOS)
-i:  Ignore case differences in paths
-W:  Do not print warnings about strange attributes
-w0: Do not print any warnings or differing attributes/owners/groups/dates
-wo: Do not compare owner/group
-wt: Do not compare the time/date
-wa: Do not compare the attributes
-v/D:Print verbose filenames/debug.
-l:  Compare attributes of symbolic links instead of files (no resolving)
-p:  Pedantic: Compare also access/imode-change time, hardlink number
-1:  Do not complain if LastDir contains an unmatched file
-2:  Do not complain if LastDir does not contain a required file.
-T:  TeX Mode: Ignore *.dvi *.aux *.toc ...
--:  Last option
EOHELP
exit }

$blocksize=512*1024;
$sepstringdefault=": ";
$sepstring='';
$home=$ENV{'HOME'};
sub readarg { $optarg=$optrest; $optrest='';
  if($optarg eq '') { $optarg=shift(@ARGV) }
}
optparse:while($ARGV[0] =~ /^-(.)(.*)$/)
{
  shift;
  while($1 ne '')
  {
    $optlett=$1; $optrest=$2;
    if   ($optlett eq 'c'){ $nocompare=1 }
    elsif($optlett eq 'd'){ $nohighdir=1 }
    elsif($optlett eq 'r'){ $norecurse=1 }
    elsif($optlett eq 't'){ $nodirtime=1 }
    elsif($optlett eq 'i'){ $ignorecase=1 }
    elsif($optlett eq 'W'){ $nowarn=1 }
    elsif($optlett eq 'w'){ &readarg;
      if   ($optarg eq '0'){ $sloppy=$nowarn=$noowner=$notime=$nodirtime=$noattrib=1 }
      elsif($optarg eq 'o'){ $noowner=1 }
      elsif($optarg eq 't'){ $notime=$nodirtime=1 }
      elsif($optarg eq 'a'){ $noattrib=1 }
    }
    elsif($optlett eq 'p'){ $pedantic=1 }
    elsif($optlett eq 'l'){ $noresolve=1 }
    elsif($optlett eq '1'){ $notforlast=1 }
    elsif($optlett eq '2'){ $notforfirst=1 }
    elsif($optlett eq 'v'){ $sepstring=$sepstringdefault }
    elsif($optlett eq 'D'){ $debug=1 }
    elsif($optlett eq 'T'){ $texmode=1 }
    elsif($optlett eq 'V'){ &version }
    elsif($optlett =~ /[hH?]/){ &help }
    elsif($optlett eq '-'){
      if   ($optrest eq ''){ last optparse }
      elsif($optrest =~ /^h(elp)?$/i || $optrest eq '?'){ &help }
      else{ die "Illegal option: --$optrest\nStopped" }
      last
    }
    else{ die "Illegal option: $optlett\nStopped" }
    last unless($optrest =~ /^(.)(.*)$/)
  }
}
&help if($ARGV[0] eq '');

# Translate pathnames into regular expressions.
# FIXME: Currently, it is impossible to quote the magic characters * ? [ ] -
# E.g. the sequence "\*" is considered as the "mask" for files starting with \
sub ProcessMask
{
  ($mask)=@_;

  # Replace multiple occurences of / by single ones, and chop / at the end:
  while($mask =~ s!//+!/!go) {}
  if($home ne "")
    { $mask =~ s!^\~/!$home/! }
  if($mask ne '/') { $mask =~ s!/$!! }
  $dorecurse=1;
  if($mask =~ /[\*\?\[]/)# If the mask contains wildcard:
  {
    if($mask =~ /^(.*\/)([^\/]*[\*\?\[].*)$/)
    {# If $mask consists of leading directory(ies) $1 and remaining mask with
     # wildcards, then we recurse, starting from $1.
      $prepend=$1;
      $mask=$2;
      $printprepend="$prepend$sepstring";
    }
    else
    {
      $prepend="./";
      $printprepend="";
    }
    # Quote mask except alphanumerics and the symbols * ? [ ] -
    $mask =~ s/([^\w\*\?\[\]\-])/\\$1/g;
    # Now replace * and ? by [^\/]* and [^\/] respectively.
    $mask =~ s/\*/[^\/]*/go; $mask =~ s/\?/[^\/]/g;
  }
  else # Otherwise (i.e. mask is actually a dir/filename):
  {
    if($mask eq '')
    {
      $prepend="./";
      $printprepend="";
    }
    else
    {
      if(-d $mask) # If we consider directories:
      {
        $prepend=$mask;
        if($prepend ne "/") { $prepend="$prepend/" }
        $printprepend="$prepend$sepstring";
        $mask='';
      }
      else
      { # For a single file, we isolate the path before, if it exists
        $dorecurse='';
        if($mask =~ /^(.*\/)([^\/]*)$/)
        {
          $prepend=$1;
          $printprepend="$prepend$sepstring";
          $mask=$2;
        }
        else
        {
          $prepend="./";
          $printprepend="";
        }
      }
    }
    # Quote mask:
    $mask =~ s/(\W)/\\$1/g;
  }
  $depth=0;
  &ProcessDir("");
}

# At the first call of ProcessDir, $prepend is a directory path
# (which should exist unless the user has typed complete rubbish),
# and this path ends with '/'.
# $mask is a regular expression which should match the path following
# $prepend.
sub ProcessDir
{
  local($act,@dir,$fname)=@_;
  $currpath=$act; &AddIfMatch(''); $act=$nextpath;
  if($isdir)
  {
    opendir(DIR,"$fullpath"); @dir=readdir(DIR); closedir(DIR);
    foreach $fname (@dir)
    {
      if(($fname ne ".") && ($fname ne ".."))
      {
        $currpath="$act$fname"; &AddIfMatch(1);
        if($isdir && $dorecurse)
          { $depth++; &ProcessDir($currpath); $depth-- }
      }
    }
  }
}

sub AddIfMatch
{
  local($sureadd)=@_;
  if($currpath eq "")
  {
    $isdir=1;
    $fullpath="$prepend.";
    $comparepath="./";
    $printpath=$prepend;
    $nextpath="";
  }
  else
  {
    $fullpath="$prepend$currpath";
    if(-d $fullpath)
      { $isdir=1; $comparepath="$currpath/" }
    else
      { $isdir=''; $comparepath=$currpath }
    $printpath="$printprepend$comparepath";
    $nextpath=$comparepath;
  }
  # We match if we either have a perfect match (from start 'til end)
  # or if /... follows.
  # If option $norecurse is used, we require in the
  # latter case that ... contains no further /
  # Moreover, we have to make an exception for the empty $mask.
  $domatch='';
  if($mask eq "")
  {
    unless(($norecurse) && ($currpath =~ /\/.*\//))
      { $domatch=1 }
  }
  else
  {
    if($ignorecase)
    {
      if($currpath =~ /^$mask$/i)
        { $domatch=1 }
      elsif($currpath =~ /^$mask\/(.*)$/i)
      {
        unless(($norecurse) && ($currpath =~ /\//))
          { $domatch=1 }
      }
    }
    else
    {
      if($currpath =~ /^$mask$/)
        { $domatch=1 }
      elsif($currpath =~ /^$mask\/(.*)$/)
      {
        unless(($norecurse) && ($currpath =~ /\//))
          { $domatch=1 }
      }
    }
  }
  # However, we do not match directories in which we have just recursed
  # (unless this is the first directory).
  # We also do not match *.dvi ... files in TeX mode
  if($isdir)
  {
    unless($sureadd)
    {
      if(($depth!=0) || ($nohighdir))
        { $domatch='' }
    }
  }
  elsif($texmode)
  {
    if($ignorecase)
    {
      if(($currpath =~ /\.dvi$/i) ||
        ($currpath =~ /\.aux$/i) ||
        ($currpath =~ /\.toc$/i) ||
        ($currpath =~ /\.lof$/i) ||
        ($currpath =~ /\.lot$/i) ||
        ($currpath =~ /\.idx$/i) ||
        ($currpath =~ /\.ind$/i) ||
        ($currpath =~ /\.glo$/i) ||
        ($currpath =~ /\.log$/i) ||
        ($currpath =~ /\.blg$/i) ||
        ($currpath =~ /\.dlg$/i) ||
        ($currpath =~ /\.ilg$/i))
        { $domatch='' }
    }
    else
    {
      if(($currpath =~ /\.dvi$/) ||
        ($currpath =~ /\.aux$/) ||
        ($currpath =~ /\.toc$/) ||
        ($currpath =~ /\.lof$/) ||
        ($currpath =~ /\.lot$/) ||
        ($currpath =~ /\.idx$/) ||
        ($currpath =~ /\.ind$/) ||
        ($currpath =~ /\.glo$/) ||
        ($currpath =~ /\.log$/) ||
        ($currpath =~ /\.blg$/) ||
        ($currpath =~ /\.dlg$/) ||
        ($currpath =~ /\.ilg$/))
        { $domatch='' }
    }
  }
  if($domatch)
  {
    if($makelast)
    {
      if($debug)
        { print "For second arg: $comparepath =~ $fullpath\n" }
      $B[$#B+1]=$comparepath;
      $Bdepth[$#Bdepth+1]=$depth;
      $Bfull[$#Bfull+1]=$fullpath;
      $Bprint[$#Bprint+1]=$printpath;
      $Bhash{$comparepath}=$#B;
    }
    else
    {
      if($debug)
        { print "For  first arg: $comparepath =~ $fullpath\n" }
      $A[$#A+1]=$comparepath;
      $Adepth[$#Adepth+1]=$depth;
      $Afull[$#Afull+1]=$fullpath;
      $Aprint[$#Aprint+1]=$printpath;
      $Ahash{$comparepath}=$#A;
    }
  }
}

if($[ < $#ARGV)
{
  for($i=$[;$i<$#ARGV;$i++)
    { &ProcessMask($ARGV[$i]) }
  $makelast=1; &ProcessMask($ARGV[$i])
}
else
{
  &ProcessMask($ARGV[$[]);
  $makelast=1; &ProcessMask("");
}

# If both lists contain only precisely one file
# (typically this is the case if "comp fileA fileB" is called),
# then we do not complain if fileA and fileB have nonmatching names.
# Instead, we just compare fileA and fileB which is what the user expects.
# This is of course an exceptional trivial case:

$i=$j=$[;
if(($#A==$i)&&($#B==$j))
{
  $name=$A[$i];
  $isdir=($name =~ /\/$/);
  # We have this special treatment only if $A and $B are both directories
  # or both files:
  if($isdir == ($B[$j] =~ /\/$/))
  {
    &comparepair;
    exit($differ);
  }
}

for($i=$[;$i<=$#A;$i++)
{
  $name=$A[$i];
  $isdir=($name =~ /\/$/);
  $j=$Bhash{$name};
  if($j ne '')
    { &comparepair }
  else
  {
    if($isdir)# If we deal with a directory and have no match:
    {
      unless($notforfirst)
      {
        $differ++; print "DIR  without matching  last arg: $Aprint[$i]\n";
      }
      # We skip until we are at the current depth again.
      $depth=$Adepth[$i];
      while(++$i<=$#A)
      {
        if($Adepth[$i]==$depth)
          { $i--; last }
      }
    }
    else
    {
      unless($notforfirst)
      {
        $differ++; print "File without matching  last arg: $Aprint[$i]\n";
      }
    }
  }
}

for($j=$[;$j<=$#B;$j++)
{
  $name=$B[$j];
  $isdir=($name =~ /\/$/);
  $i=$Ahash{$name};
  if($i eq '')
  {
    if($isdir)# If we deal with a directory and have no match:
    {
      unless($notforsecond)
      {
        $differ++; print "DIR  without matching first arg: $Bprint[$j]\n";
      }
      # We skip until we are at the current depth again.
      $depth=$Bdepth[$j];
      while(++$j<=$#B)
      {
        if($Bdepth[$j]==$depth)
          { $j--; last }
      }
    }
    else
    {
      unless($notforlast)
      {
        $differ++; print "File without matching first arg: $Bprint[$j]\n";
      }
    }
  }
}

if($differ>255)
  {$differ=255}
exit($differ);

# $i and $j must contain the indices of the files to compare.
# Moreover, $isdir must be set depending whether we have files or dirs.
sub comparepair
{
  $describe=''; $serious='';
  $Alink=(-l $Afull[$i]);
  $Blink=(-l $Bfull[$j]);
  if(($Alink) || ($Blink))
  {
    if(($Alink) && ($Blink))
    {
      unless($nowarn)
        { print "Warning: $Aprint[$i] and $Bprint[$j] are symbolic links\n" }
    }
    else
    {
      $serious=1; &adderror("link-status");
      unless($nowarn)
      {
        if($Alink)
          { print "Warning: $Aprint[$i] is a symbolic link\n" }
        else
          { print "Warning: $Bprint[$j] is a symbolic link\n" }
      }
    }
  }
  if(($Alink) && ($noresolve))
    { @Stat=lstat($Afull[$i]) }
  else
    { @Stat=stat($Afull[$i]) }
  if($#Stat<=8)
  {
    $serious=1;
    print STDERR "$comp: Can not get stat of $Afull[$i]\n";
  }
  ($dev,$ino,$Amode,$Ahlink,$Auid,$Agid,$Ardev,$Asize,$Aatime,$Amtime,$Actime,$blksize,$blocks)=@Stat;
  if(($Blink) && ($noresolve))
    { @Stat=lstat($Bfull[$j]) }
  else
    { @Stat=stat($Bfull[$j]) }
  if($#Stat<=8)
  {
    $serious=1;
    print STDERR "$comp: Can not get stat of $Bfull[$j]\n";
  }
  ($dev,$ino,$Bmode,$Bhlink,$Buid,$Bgid,$Brdev,$Bsize,$Batime,$Bmtime,$Bctime,$blksize,$blocks)=@Stat;
  $diffother='';
  if($toopedantic)
  {
    if(($Ardev) || ($Brdev))
    {
      if(($Ardev) && ($Brdev))
      {
        unless($nowarn)
          { print "Warning: $Aprint[$i] and $Bprint[$j] have unusual attributes\n" }
      }
      else
      {
        $diffother=1;
        unless($nowarn)
        {
          if($Ardev)
            { print "Warning: $Aprint[$i] has unusual attributes\n" }
          else
            { print "Warning: $Bprint[$j] has unusual attributes\n" }
        }
      }
    }
  }
  unless($noattrib)
  {
    if(($Amode != $Bmode) || ($diffother))
      { &adderror("attributes"); }
  }
  if($pedantic)
  {
    if($Ahlink !=  $Bhlink)
      { &adderror("hardlink-nr"); }
  }
  unless($noowner)
  {
    if(($Auid != $Buid) || ($Agid != $Bgid ))
      { &adderror("uid/gid"); }
  }
  if($isdir)
  {
    unless($nodirtime) { &comparetime }
  }
  else
  {
    unless($notime) { &comparetime }
    unless($nowarn)
    {
      if(($Asize <= 0) || ($Bsize <= 0))
      {
        if(($Asize <= 0) && ($Bsize <= 0))
          { print "Warning: $Aprint[$i] and $Bprint[$j] have Filesize <=0\n" }
        else
        {
          if($Asize <= 0)
            { print "Warning: $Aprint[$i] has Filesize <=0\n" }
          else
            { print "Warning: $Bprint[$j] has Filesize <=0\n" }
        }
      }
    }
    if($Asize != $Bsize)
      { &adderror("length"); $serious=1 }
    &comparefile;
    if($diffcont)
      { &adderror("content"); $serious=1 }
  }
  if($describe ne "")
  {
    if($serious)
    {
      $differ++;
      print "$Aprint[$i] and $Bprint[$j] have different $describe\n";
    }
    else
    {
      unless($sloppy)
        { print "Warning: $Aprint[$i] and $Bprint[$j] have different $describe\n" }
    }
  }
}

sub comparetime
{
  if($Amtime != $Bmtime)
    { &adderror("time") }
  if($pedantic)
  {
    if($Actime != $Bctime)
      { &adderror("inode time") }
    if($Aatime != $Batime)
      { &adderror("access time") }
  }
}

sub adderror
{
  local($addstring)=@_;
  if($describe ne "")
    { $describe="$describe, $addstring" }
  else
    { $describe=$addstring }
}

sub comparefile
{
  $diffcont='';
  if($Asize<$Bsize)
    { $toread=$Asize }
  else
    { $toread=$Bsize }
  if($toread<=0)
    { return }
  if($nocompare)
    { return }
  open(AFILE,"<$Afull[$i]") || print STDERR "$comp: Can not open $Afull[$i]\n";
  binmode AFILE;
  open(BFILE,"<$Bfull[$j]") || print STDERR "$comp: Can not open $Bfull[$j]\n";
  binmode BFILE;
  while($toread>0)
  {
    if($toread<$blocksize)
      { $readnow=$toread }
    else
      { $readnow=$blocksize }
    if((read AFILE,$ablock,$readnow)!=$readnow)
      { print STDERR "$comp: Read error for file $Afull[$i]" }
    if((read BFILE,$bblock,$readnow)!=$readnow)
      { print STDERR "$comp: Read error for file $Bfull[$j]" }
    if($ablock ne $bblock)
      { $diffcont=1; $toread=0 }
    else
      { $toread-=$readnow }
  }
  close(BFILE); close(AFILE);
}
