#!/usr/bin/perl
use strict;
use integer;
use Getopt::Long;
use Pod::Usage;

sub version {
	'$Revision: 2.2 $ '=~ /Revision:\s([^\s]*)/;
	print "comp v$1 by Martin VÃ¤th\n"
	.    "martin\@mvath.de\n";
	exit 0
}

=head1 NAME

comp - compare directories/files recursively

=head1 SYNOPSIS

=over 8

=item B<comp> [options] Dir/Mask Dir/Mask ... LastDir/Mask

=item B<comp> [options] Dir/Mask

=back

Compares the Dirs/files given by the first argument with LastDir/Mask.
In the second form, LastDir/Mask defaults to ""
The files are always compared binary.
Also metadata like timestamps(attributes is compared.
When calling from a shell, do not forget '...' around Mask.

Options B<--man> (or B<-?>) respectively B<--help> (or B<-h>)
give an explicit help as a manpage resp. an ascii-text.

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--down> or B<-d>

Do B<not> compare metadata of highest directories.

=item B<--norecurse> or B<-r>

Do B<not> compare recursively (except for one step in directory arguments)

=item B<--nocomp> or B<-c>

Compare only metadata but not the contents of the files.
This is much faster, but will not find differences in content, of course.

=item B<--ignore-case> B<-i>

Ignore case differences in paths (useful for FAT)

=item B<--verbose> or B<-v>

print verbose filenames

=item B<--debug> or B<-D>

Debug

=item B<--noresolve> or B<-l>

Compare attributes of symbolic links instead of files (no resolving)

=item B<--pedantic> or B<-p>

Compare also access/status-change time, hardlink number, and device attributes

=item B<--too-pedantic> or B<-P>

As B<-p>, but compare also device identifiers.

=item B<--only-first> or B<-1>

Do not complain if LastDir contains an unmatched file

=item B<--only-last> or B<-2>

Do not complain if LastDir does not contain a required file.

=item B<--tex> or B<-x>

TeX Mode: Ignore *.dvi *.aux *.toc ...

=item B<--neverwarn> or B<-w>

Do not print warnings (differing/strange attributes/owners/groups/timestamps).
This is slightly stronger than B<-Wota>

=item B<--nowarn> or B<-W>

Do not print warnings about strange attributes

=item B<--noowner> or B<-o>

Do not print warnings about differing ownership.

=item B<--notime> or B<-t>

Do not print warnings about differing timestamps. (This implies B<-T>)

=item B<--nodirtime> or B<-D>

Do not compare timestamps for B<directories> (useful for FAT)

=item B<--noattr> or B<-a>

Do not print warnings about differing attributes.

=item B<--version> or B<-V>

Print version number

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

our $blocksize = 512 * 1024;
our $sepstring = '';
our $sepstringdefault = ': ';
our $home = $ENV{'HOME'};

# Default for the Options:

our $nohighdir = '';
our $norecurse = '';
our $nocompare = '';
our $ignorecase = '';
our $sloppy = '';
our $nowarn = '';
our $noowner = '';
our $notime = '';
our $nodirtime = '';
our $noattrib = '';
our $noresolve = '';
our $pedantic = '';
our $toopedantic = '';
our $notforlast = '';
our $notforfirst = '';
our $texmode = '';
our $debug = '';
our $verbose = '';

# Parse Options:

$Getopt::Long::bundling = 1;
GetOptions(
	'help|h', sub { pod2usage(1) },
	'man|?', sub { pod2usage(-verbose=>2) },
	'version|V', \&version,
	'down|d', \$nohighdir,
	'norecurse|r', \$norecurse,
	'nocomp|c', \$nocompare,
	'ignore-case|i', \$ignorecase,
	'neverwarn|w', \$sloppy,
	'nowarn|W', \$nowarn,
	'noowner|o', \$noowner,
	'notime|t', \$notime,
	'nodirtime|T', \$nodirtime,
	'noattr|a', \$noattrib,
	'noresolve|l', \$noresolve,
	'pedantic|p', \$pedantic,
	'too-pedantic|P', \$toopedantic,
	'only-first|1', \$notforlast,
	'only-last|2', \$notforfirst,
	'tex|x', \$texmode,
	'debug|D', \$debug,
	'verbose|v', \$verbose,
) or pod2usage(2);

if($notime) {
	$nodirtime = 1;
}

if($toopedantic) {
	$pedantic = 1;
}

if($verbose) {
	$sepstring = $sepstringdefault;
}

if($sloppy) {
	$nowarn = $noowner = $notime = $nodirtime = $noattrib = 1
}

($#ARGV >= 0 ) or pod2usage(2);

our ($dorecurse, $prepend, $printprepend);
our ($currpath, $isdir, $fullpath, $comparepath);
our ($printpath, $nextpath, $domatch);
our ($depth,$makelast,$name);
our $mask = '';
our $differ = 0;
our (@A, @Adepth, @Afull, @Aprint, %Ahash);
our (@B, @Bdepth, @Bfull, @Bprint, %Bhash);

# Translate pathnames into regular expressions.
# FIXME: Currently, it is impossible to quote the magic characters * ? [ ] -
# E.g. the sequence "\*" is considered as the "mask" for files starting with \
sub ProcessMask
{
	($mask) = @_;

	# Replace multiple occurences of / by single ones, and chop / at the end:
	while($mask =~ s!//+!/!go) {}
	if($home ne '') {
		$mask =~ s!^\~/!$home/!
	}
	if($mask ne '/') {
		$mask =~ s!/$!!
	}
	$dorecurse = 1;
	if($mask =~ /[\*\?\[]/) { # If the mask contains wildcard:
		if($mask =~ /^(.*\/)([^\/]*[\*\?\[].*)$/) {
			# If $mask consists of leading directory(ies) $1 and remaining mask with
			# wildcards, then we recurse, starting from $1.
			$prepend = $1;
			$mask = $2;
			$printprepend = "$prepend$sepstring";
		}
		else {
			$prepend = './';
			$printprepend = '';
		}
		# Quote mask except alphanumerics and the symbols * ? [ ] -
		$mask =~ s/([^\w\*\?\[\]\-])/\\$1/g;
		# Now replace * and ? by [^\/]* and [^\/] respectively.
		$mask =~ s/\*/[^\/]*/go; $mask =~ s/\?/[^\/]/g;
	}
	else { # Otherwise (i.e. mask is actually a dir/filename):
		if($mask eq '') {
			$prepend = './';
			$printprepend = '';
		}
		else {
			if(-d $mask) { # If we consider directories:
				$prepend = $mask;
				if($prepend ne "/") {
					$prepend = "$prepend/"
				}
				$printprepend = "$prepend$sepstring";
				$mask = '';
			}
			else { # For a single file, we isolate the path before, if it exists
				$dorecurse = '';
				if($mask =~ /^(.*\/)([^\/]*)$/) {
					$prepend = $1;
					$printprepend = "$prepend$sepstring";
					$mask = $2;
				}
				else {
					$prepend = './';
					$printprepend = '';
				}
			}
		}
		# Quote mask:
		$mask =~ s/(\W)/\\$1/g;
	}
	$depth = 0;
	&ProcessDir('')
}

# At the first call of ProcessDir, $prepend is a directory path
# (which should exist unless the user has typed complete rubbish),
# and this path ends with '/'.
# $mask is a regular expression which should match the path following
# $prepend.
sub ProcessDir
{
	my($act, @dir, $fname) = @_;
	$currpath = $act; &AddIfMatch(''); $act = $nextpath;
	if(!$isdir) {
		return
	}
	opendir(DIR, $fullpath); @dir = readdir(DIR); closedir(DIR);
	foreach $fname (@dir) {
		if(($fname ne '.') && ($fname ne '..')) {
			$currpath = "$act$fname"; &AddIfMatch(1);
			if($isdir && $dorecurse) {
				++$depth; &ProcessDir($currpath); $depth--
			}
		}
	}
}

sub AddIfMatch
{
	my($sureadd) = @_;
	if($currpath eq '') {
		$isdir = 1;
		$fullpath = "$prepend.";
		$comparepath = './';
		$printpath = $prepend;
		$nextpath = '';
	}
	else {
		$fullpath = "$prepend$currpath";
		if(-d $fullpath) {
			$isdir = 1; $comparepath = "$currpath/"
		}
		else {
			$isdir = ''; $comparepath = $currpath
		}
		$printpath = "$printprepend$comparepath";
		$nextpath = $comparepath;
	}
	# We match if we either have a perfect match (from start 'til end)
	# or if /... follows.
	# If option $norecurse is used, we require in the
	# latter case that ... contains no further /
	# Moreover, we have to make an exception for the empty $mask.
	$domatch = '';
	if($mask eq '') {
		unless(($norecurse) && ($currpath =~ /\/.*\//)) {
			$domatch = 1
		}
	}
	else {
		if($ignorecase) {
			if($currpath =~ /^$mask$/i) {
				$domatch = 1
			}
			elsif($currpath =~ /^$mask\/(.*)$/i) {
				unless(($norecurse) && ($currpath =~ /\//)) {
					$domatch = 1
				}
			}
		}
		else {
			if($currpath =~ /^$mask$/) {
				$domatch = 1
			}
			elsif($currpath =~ /^$mask\/(.*)$/) {
				unless(($norecurse) && ($currpath =~ /\//)) {
					$domatch = 1
				}
			}
		}
	}
	# However, we do not match directories in which we have just recursed
	# (unless this is the first directory).
	# We also do not match *.dvi ... files in TeX mode
	if($isdir) {
		unless($sureadd) {
			if(($depth != 0) || ($nohighdir)) {
				$domatch = ''
			}
		}
	}
	elsif($texmode) {
		if($ignorecase) {
			if(($currpath =~ /\.dvi$/i) ||
				($currpath =~ /\.aux$/i) ||
				($currpath =~ /\.toc$/i) ||
				($currpath =~ /\.lof$/i) ||
				($currpath =~ /\.lot$/i) ||
				($currpath =~ /\.idx$/i) ||
				($currpath =~ /\.ind$/i) ||
				($currpath =~ /\.glo$/i) ||
				($currpath =~ /\.log$/i) ||
				($currpath =~ /\.blg$/i) ||
				($currpath =~ /\.dlg$/i) ||
				($currpath =~ /\.ilg$/i)) {
				$domatch = ''
			}
		}
		else {
			if(($currpath =~ /\.dvi$/) ||
				($currpath =~ /\.aux$/) ||
				($currpath =~ /\.toc$/) ||
				($currpath =~ /\.lof$/) ||
				($currpath =~ /\.lot$/) ||
				($currpath =~ /\.idx$/) ||
				($currpath =~ /\.ind$/) ||
				($currpath =~ /\.glo$/) ||
				($currpath =~ /\.log$/) ||
				($currpath =~ /\.blg$/) ||
				($currpath =~ /\.dlg$/) ||
				($currpath =~ /\.ilg$/)) {
				$domatch = ''
			}
		}
	}
	if($domatch) {
		if($makelast) {
			if($debug) {
				print "For second arg: $comparepath =~ $fullpath\n"
			}
			$B[$#B+1] = $comparepath;
			$Bdepth[$#Bdepth+1] = $depth;
			$Bfull[$#Bfull+1] = $fullpath;
			$Bprint[$#Bprint+1] = $printpath;
			$Bhash{$comparepath} = $#B;
		}
		else
		{
			if($debug) {
				print "For  first arg: $comparepath =~ $fullpath\n"
			}
			$A[$#A+1] = $comparepath;
			$Adepth[$#Adepth+1] = $depth;
			$Afull[$#Afull+1] = $fullpath;
			$Aprint[$#Aprint+1] = $printpath;
			$Ahash{$comparepath} = $#A;
		}
	}
}

our $i;
our $j;

if($[ < $#ARGV) {
	for($i = $[; $i < $#ARGV; ++$i) {
		&ProcessMask($ARGV[$i])
	}
	$makelast = 1; &ProcessMask($ARGV[$i])
}
else {
	&ProcessMask($ARGV[$[]);
	$makelast = 1; &ProcessMask('')
}

# If both lists contain only precisely one file
# (typically this is the case if "comp fileA fileB" is called),
# then we do not complain if fileA and fileB have nonmatching names.
# Instead, we just compare fileA and fileB which is what the user expects.
# This is of course an exceptional trivial case:

$i = $j = $[;
if(($#A == $i) && ($#B == $j)) {
	$name = $A[$i];
	$isdir = ($name =~ /\/$/);
	# We have this special treatment only if $A and $B are both directories
	# or both files:
	if($isdir == ($B[$j] =~ /\/$/)) {
		&comparepair;
		exit($differ);
	}
}

for($i = $[; $i <= $#A; ++$i) {
	$name = $A[$i];
	$isdir = ($name =~ /\/$/);
	$j = $Bhash{$name};
	if($j ne '') {
		&comparepair
	}
	else {
		if($isdir) {# If we deal with a directory and have no match:
			unless($notforfirst) {
				++$differ; print "DIR  without matching  last arg: $Aprint[$i]\n";
			}
			# We skip until we are at the current depth again.
			$depth = $Adepth[$i];
			while(++$i <= $#A) {
				if($Adepth[$i] == $depth) {
					--$i; last
				}
			}
		}
		else {
			unless($notforfirst) {
				++$differ; print "File without matching  last arg: $Aprint[$i]\n";
			}
		}
	}
}

for($j = $[; $j <= $#B; ++$j) {
	$name = $B[$j];
	$isdir = ($name =~ /\/$/);
	$i = $Ahash{$name};
	if($i eq '') {
		if($isdir) { # If we deal with a directory and have no match:
			unless($notforlast) {
				++$differ;
				print "DIR  without matching first arg: $Bprint[$j]\n";
			}
			# We skip until we are at the current depth again.
			$depth = $Bdepth[$j];
			while(++$j <= $#B) {
				if($Bdepth[$j] == $depth) {
					$j--; last
				}
			}
		}
		else {
			unless($notforlast) {
				++$differ;
				print "File without matching first arg: $Bprint[$j]\n";
			}
		}
	}
}

if($differ > 127) {
	$differ = 127
}
exit($differ);

our ($describe, $serious);
our ($diffcont, $toread, $readnow, $ablock, $bblock);
our ($Alink, $Blink);
our @Stat;
our ($dev, $ino, $blksize, $blocks);
our ($Amode, $Ahlink, $Auid, $Agid, $Ardev, $Asize, $Aatime, $Amtime, $Actime);
our ($Bmode, $Bhlink, $Buid, $Bgid, $Brdev, $Bsize, $Batime, $Bmtime, $Bctime);


# $i and $j must contain the indices of the files to compare.
# Moreover, $isdir must be set depending whether we have files or dirs.
sub comparepair
{
	$describe = ''; $serious = '';
	$Alink = (-l $Afull[$i]);
	$Blink = (-l $Bfull[$j]);
	if(($Alink) || ($Blink)) {
		if(($Alink) && ($Blink)) {
			unless($nowarn) {
				&warn("$Aprint[$i] and $Bprint[$j] are symbolic links")
			}
		}
		else {
			$serious = 1; &adderror("link-status");
			unless($nowarn) {
				if($Alink) {
					&warn("$Aprint[$i] is a symbolic link")
				}
				else {
					&warn("$Bprint[$j] is a symbolic link")
				}
			}
		}
	}
	if(($Alink) && ($noresolve)) {
		@Stat = lstat($Afull[$i])
	}
	else {
		@Stat = stat($Afull[$i])
	}
	if($#Stat <= 8) {
		$serious = 1;
		&error("cannot get stat of $Afull[$i]");
	}
	($dev, $ino, $Amode, $Ahlink, $Auid, $Agid, $Ardev, $Asize, $Aatime, $Amtime, $Actime, $blksize, $blocks) = @Stat;
	if(($Blink) && ($noresolve)) {
		@Stat = lstat($Bfull[$j])
	}
	else {
		@Stat = stat($Bfull[$j])
	}
	if($#Stat <= 8) {
		$serious = 1;
		&error("cannot get stat of $Bfull[$j]");
	}
	($dev, $ino, $Bmode, $Bhlink, $Buid, $Bgid, $Brdev, $Bsize, $Batime, $Bmtime, $Bctime, $blksize, $blocks) = @Stat;
	my $diffother = '';
	if($toopedantic) {
		if(($Ardev) || ($Brdev)) {
			if(($Ardev) && ($Brdev)) {
				unless($nowarn) {
					&warn("$Aprint[$i] and $Bprint[$j] have unusual attributes")
				}
			}
			else {
				$diffother = 1;
				unless($nowarn) {
					if($Ardev) {
						&warn("$Aprint[$i] has unusual attributes")
					}
					else {
						&warn("$Bprint[$j] has unusual attributes")
					}
				}
			}
		}
	}
	unless($noattrib) {
		if(($Amode != $Bmode) || ($diffother)) {
			&adderror('attributes')
		}
	}
	if($pedantic) {
		if($Ahlink != $Bhlink) {
			&adderror('hardlink-nr')
		}
	}
	unless($noowner) {
		if(($Auid != $Buid) || ($Agid != $Bgid )) {
			&adderror('uid/gid')
		}
	}
	if($isdir) {
		unless($nodirtime) {
			&comparetime
		}
	}
	else {
		unless($notime) {
			&comparetime
		}
		unless($nowarn) {
			if(($Asize <= 0) || ($Bsize <= 0)) {
				if(($Asize <= 0) && ($Bsize <= 0)) {
					&warn("$Aprint[$i] and $Bprint[$j] have Filesize <=0")
				}
				else {
					if($Asize <= 0) {
						&warn("$Aprint[$i] has Filesize <=0")
					}
					else {
						&warn("$Bprint[$j] has Filesize <=0")
					}
				}
			}
		}
		if($Asize != $Bsize) {
			&adderror('length'); $serious = 1
		}
		&comparefile;
		if($diffcont) {
			&adderror('content'); $serious = 1
		}
	}
	if($describe ne '') {
		if($serious) {
			++$differ;
			print "$Aprint[$i] and $Bprint[$j] have different $describe\n";
		}
		else {
			unless($sloppy) {
				&warn("$Aprint[$i] and $Bprint[$j] have different $describe");
			}
		}
	}
}

sub comparetime
{
	if($Amtime != $Bmtime) {
		&adderror('time')
	}
	if($pedantic) {
		if($Actime != $Bctime) {
			&adderror('status time')
		}
		if($Aatime != $Batime) {
			&adderror('access time')
		}
	}
}

sub adderror
{
	my($addstring) = @_;
	if($describe ne '') {
		$describe = "$describe, $addstring"
	}
	else {
		$describe = $addstring
	}
}

sub comparefile
{
	$diffcont = '';
	if($Asize<$Bsize) {
		$toread = $Asize
	}
	else {
		$toread = $Bsize
	}
	if($toread <= 0) {
		return
	}
	if($nocompare) {
		return
	}
	open(AFILE, '<', $Afull[$i]) || &error("cannot open $Afull[$i]");
	binmode AFILE;
	open(BFILE, '<', $Bfull[$j]) || &error("cannot open $Bfull[$j]");
	binmode BFILE;
	while($toread > 0) {
		if($toread < $blocksize) {
			$readnow = $toread
		}
		else {
			$readnow = $blocksize
		}
		if((read AFILE, $ablock, $readnow) != $readnow) {
			&error("read error for file $Afull[$i]")
		}
		if((read BFILE, $bblock, $readnow) != $readnow) {
			&error("read error for file $Bfull[$j]")
		}
		if($ablock ne $bblock) {
			$diffcont = 1; $toread = 0
		}
		else {
			$toread -= $readnow
		}
	}
	close(BFILE); close(AFILE);
}

sub error
{
	print STDERR 'comp: ', $_[0], "\n"
}

sub warn
{
	print 'warning: ', $_[0], "\n"
}
