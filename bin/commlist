#!/usr/bin/env perl
BEGIN { require 5.006_001 }
package Commlist;
our $VERSION = 'v2.2.4';
eval { $VERSION = version->declare($VERSION) };
eval 'use version 0.77; $VERSION = version->declare($VERSION)' if($@);

use warnings;
use strict;
use integer;
use Getopt::Long 2.24 ();
#use Pod::Usage ();

=encoding UTF-8

=head1 NAME

commlist - print lines common/not common to two lists of files

=head1 SYNOPSIS

B<commlist> [options] I<fileA1> I<fileA2> ... B<""> I<fileB1> I<fileB2> ...

To get an extended help, type B<commlist --man> or B<commlist -?>

=head1 DESCRIPTION

The files I<fileA...> are compared against the files I<fileB...>,
and lines of I<fileA...> which are also/not occurring in one of the files
I<fileB...> are output in a first/second columns.
Option B<-1> or B<-2> suppresses the corresponding column.
The special name B<-> specifies standard input.

In contrast to the standard unix B<comm> utility, unsorted input data is ok.
Moreover, the order of the lines output corresponds to that of I<fileA...>

=head1 OPTIONS

=over 8

=item B<--help> or B<-h>

Display brief help.

=item B<--man> or B<-?>

Display extended help as a manpage.

=item B<-1> or B<-2>

Suppress the first or second column of output, respectively.

=item B<--common=>I<string> or B<-c> I<string>

Prefix the column of lines also occurring in I<fileB...> with I<string>.
The default is the empty string.

=item B<--only=>I<string> or B<-o> I<string>

Prefix the column of lines not occurring in I<fileB...> with I<string>.
The default is the empty string or the tab character, depending on whether
this is the second column or not.

=item B<--version> or B<-v>

print version number

=item B<-->

Last option

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Global variables;:

my $name = 'commlist';

# Option variables:

my $suppress1 = '';
my $suppress2 = '';
my $only = undef;
my $common = '';

# Functions

sub warn {
	print(STDERR $name, ': warning: ', @_, "\n")
}

sub version {
	print($name, ' ', $VERSION, "\n");
	exit(0)
}

sub pod2usage {
	require Pod::Usage;
	&Pod::Usage::pod2usage
}

# Parse Options:

Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
	'help|h', sub { &pod2usage(0) },
	'man|?', sub { &pod2usage(-verbose => 2, -exit => 0) },
	'only|o=s', \$only,
	'common|c=s', \$common,
	'1', \$suppress1,
	'2', \$suppress2,
	'version|V', \&version
) or &pod2usage(2);

$only = ($suppress1 ? '' : "\t") unless(defined($only));

my @fileA = ();
my @fileB = ();

my $found = '';
foreach (@ARGV) {
	if($found) {
		push(@fileB, $_);
		next
	}
	if($_ eq '') {
		$found = 1
	} else {
		push(@fileA, $_)
	}
}
&pod2usage(1) unless($found);
exit(0) unless(@fileA);

my %B = ();
for my $file (@fileB) {
	my ($fh, $close);
	if($file eq '-') {
		$fh = \*STDIN;
		$close = ''
	} else {
		unless(open($fh, '<', $file)) {
			&warn('cannot open ', $file);
			next
		}
		$close = 1
	}
	while(<$fh>) {
		chomp();
		$B{$_} = undef
	}
	close($fh) if($close)
}
for my $file (@fileA) {
	my ($fh, $close);
	if($file eq '-') {
		$fh = \*STDIN;
		$close = ''
	} else {
		unless(open($fh, '<', $file)) {
			&warn('cannot open ', $file);
			next
		}
		$close = 1
	}
	while(<$fh>) {
		my $c = $_;
		chomp($c);
		if(exists($B{$c})) {
			print($common, $_) unless($suppress1)
		} else {
			print($only, $_) unless($suppress2)
		}
	}
	close($fh) if($close)
}
