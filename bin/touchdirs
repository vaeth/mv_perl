#!/usr/bin/perl
use strict;
use integer;
no  sort 'stable';
use Getopt::Long;
use Pod::Usage;
use File::Find;
use File::Spec;
use Fcntl ':mode';
use Time::localtime;
#use Time::HiRes; # needed unless -R is used

sub version {
	print("Touchdirs v2.7 by Martin VÃ¤th\n",
		"martin\@mvath.de\n");
	exit(0)
}

=head1 NAME

touchdirs - Touch directories according to their newest file

=head1 SYNOPSIS

B<touchdirs> [options] I<dirs>

=head1 DESCRIPTION

Look for all files in I<dirs> and then change all dirs' mtimestamps according
to the newest file contained (empty dirs' mtimestamps are ignored).
The used resolution of timestamps is one second, independent of the
properties of the filesystem.

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--round> or B<-r>

On filestamps with non-integer seconds, drop to integers and
modify recursed filestamps correspondingly.

=item B<--rounding>

On filestamps with non-integer seconds, drop to integers,
but do not touch non-directories only for this modification.

=item B<--roundread> or B<-R>

As B<--rounding> but do not even touch directories for the modification.

=item B<--force> or B<-f>

Touch dirs even if time did not change.
This has effects e.g. on copy-on-write filesystems or with B<--rounding>.

=item B<--all> or B<-a>

As B<--force> but additionally touch all files

=item B<--access> or B<-A>

Let access time be the same as modification time.

=item B<--ignore=>I<regexp> or B<-i> I<regexp>

Ignore files whose (relative) path matches I<regexp>.

=item B<--ignore-case=>I<regexp> or B<-I> I<regexp>

Ignore files whose (relative) path matches I<regexp>, ignoring case.

=item B<--dotdirs> or B<-d>

Ignore .* dirs. Equivalent to B<--ignore=/\..+/>

=item B<--dotfiles> or B<-D>

Ignore .* files. Equivalent to B<--ignore=/\.[^/]+$>

=item B<--dot>

Ignore .* files/dirs. Equivalent to B<--ignore=/\.> or to B<-dD>

=item B<--git> or B<-g>

Ignore .git dirs. Equivalent to B<--ignore=/\.git/>

=item B<--follow-link> or B<-F>

Follow links to further directories.
Also use time of the file the link points to instead of time of the link.

=item B<--quiet> or B<-q>

Do not print ignored directories.
If specified twice, do not print executed commands, either.

=item B<--dry-run> or B<--show> or B<-n> or B<-s>

Only show what would be done, do not alter anything.

=item B<--version> or B<-V>

Print version number

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Options and their default:

my $access = '';
my $force = '';
my $all = '';
my $round = '';
my $rounding = '';
my $roundread = '';
my $show = '';
my $follow = '';
my $quiet = 0;
my @exclude = ();
my @iexclude = ();

# Global Variables:

my $hires_write;
my %DIR;
my $count;
my @topdirs;

# Functions:

sub not_equal {
	my ($a, $b) = @_;
	no integer;
	return ($a != $b)
}

sub is_equal {
	my ($a, $b) = @_;
	no integer;
	return ($a == $b)
}

sub myctime {
	my ($rtime) = @_;
	my ($time, $itime);
	my $hires_writing = '';
	my $arg = '-t';
	my $format = '%04d%02d%02d%02d%02d%s%02d%s';
	my $dot = '.';
	my $rest = '';
	if($hires_write) {
		$itime = int($rtime);
		$time = localtime($itime);
		if(&not_equal($itime, $rtime)) {
			no integer;
			$hires_writing = 1;
			$rest = $rtime - $itime;
			$rest =~ s/^([^\.]*)\./\./ or
				die('strange number conversion');
			$arg = '-d';
			$format = '%04d-%02d-%02d %02d:%02d:%s%02d%s';
			$dot = ''
		}
	} else {
		$time = localtime($rtime)
	}
	return ($hires_writing, $arg, sprintf($format,
			(1900 + $time->year()), 1 + $time->mon(), $time->mday(),
			$time->hour(), $time->min(), $dot, $time->sec(), $rest))
}

sub touchit {
	my ($atime, $mtime, $file) = @_;
	return if($show && ($quiet >= 2));
	my ($cm, $cmarg, $cmtime) = &myctime($mtime);
	if((!$follow) && (-l $file)) {
		if(&is_equal($atime, $mtime)) {
			&shprint("touch -h    $cmarg " . &shq($cmtime), $file) if($quiet < 2);
			system('touch', '-h', $cmarg, $cmtime, '--', $file) unless($show);
		} else {
			&shprint("touch -h -m $cmarg " . &shq($cmtime), $file) if($quiet < 2);
			system('touch', '-h', '-m', $cmarg, $cmtime, '--', $file) unless($show);
			my ($ca, $caarg, $catime) = &myctime($atime);
			&shprint("touch -h -a $caarg " . &shq($catime), $file) if($quiet < 2);
			system('touch', '-h', '-a', $caarg, $catime, '--', $file) unless($show);
		}
		return
	}
	if(&is_equal($atime, $mtime)) {
		&shprint("touch       $cmarg " . &shq($cmtime), $file) if($quiet < 2);
		if($cm && !$show) {
			system('touch', $cmarg, $cmtime, '--', $file);
			return
		}
	} else {
		my ($ca, $caarg, $catime) = &myctime($atime);
		&shprint("touch    -m $cmarg " . &shq($cmtime), $file) if($quiet < 2);
		my $system = ((!$show) && ($cm || $ca));
		system('touch', '-m', $cmarg, $cmtime, '--', $file) if($system);
		&shprint("touch    -a $caarg " . &shq($catime), $file) if($quiet < 2);
		if($system) {
			system('touch', '-a', $caarg, $catime, '--', $file);
			return
		}
	}
	utime($atime, $mtime, $file) unless($show)
}

sub exclude {
	my ($path) = @_;
	foreach my $regex (@exclude) {
		if($path =~ $regex) {
			return 1
		}
	}
	return ''
}

sub printcomment {
	my ($text, $dir) = @_;
	$dir =~  s/\n/\n\#\ /gom;
	printf("%s%-29s%s\n", '# ', $text, $dir)
}

sub my_split {
	my ($arr, $dir) = @_;
	@$arr = File::Spec->splitdir($dir);
}

sub my_cat {
	return File::Spec->catdir(@_)
}

sub my_amtime {
	my ($file) = @_;
	return (((!$follow) && (-l $file)) ? lstat($file) :
		($roundread ? stat($file) : Time::HiRes::stat($file)))[8, 9]
}

sub dotouch {
	if(-d $_) {
		return if($follow || !(-l $_));
	}
	if(&exclude($_)) {
		&printcomment("Ignored:", $_) unless($quiet);
		return
	}
	my @dirs;
	&my_split(\@dirs, $_);
	for my $i (@topdirs) {
		if((!@dirs) || ($i ne shift(@dirs))) {
			&printcomment("Prune:", $_);
			$File::Find::prune = 1;
			return
		}
	}
	my $filename = &my_cat(@topdirs, @dirs);
	my ($atime, $mtime) = &my_amtime($filename);
	my $write = $all;
	if($rounding) {
		my ($oldatime, $oldmtime) = ($atime, $mtime);
		($atime, $mtime) = (int($atime), int($mtime));
		if($round) {
			$write = 1 if(&not_equal($oldatime, $atime) || &not_equal($oldmtime, $mtime))
		}
	}
	if($access && &not_equal($atime, $mtime)) {
		$atime = $mtime;
		&touchit($atime, $mtime, $filename)
	} elsif($write) {
		&touchit($atime, $mtime, $filename)
	}
	while(@dirs) {
		pop(@dirs);
		my $dirname = &my_cat(@topdirs, @dirs);
		my $array = $DIR{$dirname};
		if(defined($array)) {
			my ($oriatime, $orimtime) = @$array;
			if($atime > $oriatime) {
				$array->[0] = $atime
			}
			if($mtime > $orimtime) {
				$array->[1] = $mtime
			}
		} else {
			$DIR{$dirname} = [ $atime, $mtime, scalar(@dirs), $count++ ]
		}
	}
}

sub shq {
	my ($a) = (@_);
	$a =~ s/\'/\'\\\'\'/go; $a = "'$a'";
	$a =~ s/(^|[^\\])\'([\da-zA-Z\_\-\,\.\:\/]*)\'/$1$2/g;
	return(($a ne '') ? $a : "''");
}

sub shqs {
	return(' ' . &shq($_[0]))
}

sub shdash {
	my($s, $r, $t) = (shift, '', '');
	for my $i (@_) {
		$t = 1 if($i =~ /^[-+]/);
		$r .= &shqs($i)
	}
	return (($t) ? ($s . ' --' . $r) : ($s . $r))
}

sub shprint {
	print(&shdash(@_), "\n")
}

# Parse Options:

$Getopt::Long::bundling = 1;
GetOptions(
	'help|h', sub { pod2usage(1) },
	'man|?', sub { pod2usage(-verbose => 2) },
	'version|V', \&version,
	'round|r', \$round,
	'rounding', \$rounding,
	'roundread|R', \$roundread,
	'force|f', \$force,
	'all|a', \$all,
	'access|A', \$access,
	'ignore|i=s', \@exclude,
	'ignore-case|I=s', \@iexclude,
	'dotdir|d', sub { push(@exclude, qr'/\..+/') },
	'dotfile|D', sub { push(@exclude, qr'/\.[^/]+$') },
	'dot', sub { push(@exclude, qr'/\.') },
	'git|g', sub { push(@exclude, qr'/\.git/') },
	'show|dry-run|s|n', \$show,
	'quiet|q+', \$quiet,
	'follow-link|F', \$follow,
	'nofollow-link|no-follow-link', sub { $follow = '' }
) or pod2usage(2);
pod2usage(-verbose => 2) unless(@ARGV);

# Set dependent options
$rounding = 1 if($round || $roundread);
if($all) {
	$force = 1;
	$round = ''
}

# Set globals depending on options
$hires_write = !$rounding;
unless($roundread) {
	require Time::HiRes;
	Time::HiRes->import();
}

# Compile regular expressions and make one array:
for my $i (@exclude) {
	$i = qr/$i/ if(ref($i) ne 'Regexp')
}
for my $i (@iexclude) {
	$i = qr/$i/i if(ref($i) ne 'Regexp');
	Push(@exclude, $i)
}
@iexclude = undef;

# Main Loop
foreach my $currdir (@ARGV) {
	%DIR = ();
	$count = 0;
	&my_split(\@topdirs, File::Spec->canonpath($currdir));
	my $topdir = &my_cat(@topdirs);
	unless(-d $topdir) {
		&printcomment("Ignoring non-directory:", $currdir);
		next
	}
	find({
		bydepth => 1,
		follows => $follow,
		follow_skip => 2,
		no_chdir => 1,
		dangling_symlinks => '',
		wanted => \&dotouch
	}, $topdir);
	my @DIR = sort {
		my $x = $DIR{$a};
		my $y = $DIR{$b};
		my $ret = -($x->[2] cmp $y->[2]);
		return $ret if($ret);
		return -($x->[3] cmp $y->[3])
	} keys(%DIR);
	foreach my $dir (@DIR) {
		my ($atime, $mtime) = &my_amtime($dir);
		my ($newatime, $newmtime) = @{$DIR{$dir}};
		if($force || &not_equal($atime, $newatime) || &not_equal($mtime, $newmtime)) {
			&touchit($newmtime, $newatime, $dir)
		}
	}
}
1;
