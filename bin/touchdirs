#!/usr/bin/perl
use strict;
use integer;
use Getopt::Long;
use Pod::Usage;
use File::Find;
use Fcntl ':mode';
use Time::localtime;

my $dirsep = '/';

sub version () {
	print("Touchdirs v2.3 by Martin VÃ¤th\n",
		"martin\@mvath.de\n");
	exit 0
}

=head1 NAME

touchdirs - Touch directories according to their newest file

=head1 SYNOPSIS

B<touchdirs> [options] I<dirs>

=head1 DESCRIPTION

Look for all files in I<dirs> and then change all dirs' mtimestamps according
to the newest file contained (empty dirs' mtimestamps are ignored).
The used resolution of timestamps is one second, independent of the
properties of the filesystem.

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--force> or B<-f>

Touch dirs even if time did not change: This sets the filestamps to a
full second and has other effects e.g. on copy-on-write filesystems.

=item B<--all> or B<-a>

As B<--force> but additionally touch all files

=item B<--access> or B<-A>

Let access time be the same as modification time.

=item B<--ignore=>I<regexp> or B<-i> I<regexp>

Ignore files whose (relative) path matches I<regexp>.

=item B<--ignore-case=>I<regexp> or B<-I> I<regexp>

Ignore files whose (relative) path matches I<regexp>, ignoring case.

=item B<--dotdirs> or B<-d>

Ignore .* dirs. Equivalent to B<--ignore=/\..+/>

=item B<--dotfiles> or B<-D>

Ignore .* files. Equivalent to B<--ignore=/\.[^/]+$>

=item B<--dot>

Ignore .* files/dirs. Equivalent to B<--ignore=/\.> or to B<-dD>

=item B<--git> or B<-g>

Ignore .git dirs. Equivalent to B<--ignore=/\.git/>

=item B<--follow-link> or B<-F>

Follow links to further directories.
Also use time of the file the link points to instead of time of the link.

=item B<--quiet> or B<-q>

Do not print ignored directories.
If specified twice, do not print executed commands, either.

=item B<--dry-run> or B<--show> or B<-n> or B<-s>

Only show what would be done, do not alter anything.

=item B<--version> or B<-V>

Print version number

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Default for the Options:

my $access = '';
my $force = '';
my $all = '';
my $show = '';
my $follow = '';
my $quiet = 0;
my @exclude = ();
my @iexclude = ();

# Parse Options:

$Getopt::Long::bundling = 1;
GetOptions(
	'help|h', sub { pod2usage(1) },
	'man|?', sub { pod2usage(-verbose => 2) },
	'version|V', \&version,
	'force|f', \$force,
	'all|a', \$all,
	'access|A', \$access,
	'ignore|i=s', \@exclude,
	'ignore-case|I=s', \@iexclude,
	'dotdir|d', sub { push(@exclude, qr'/\..+/') },
	'dotfile|D', sub { push(@exclude, qr'/\.[^/]+$') },
	'dot', sub { push(@exclude, qr'/\.') },
	'git|g', sub { push(@exclude, qr'/\.git/') },
	'show|dry-run|s|n', \$show,
	'quiet|q+', \$quiet,
	'follow-link|F', \$follow,
	'nofollow-link', sub { $follow = '' }
) or pod2usage(2);
($#ARGV >= 0) or pod2usage(-verbose => 2);

$force = 1 if($all);

# Compile regular expressions and make one array:
my $dirsepre = qr/^(.*)$dirsep.*$/o;
my $dirseptail = qr/$dirsep+$/o;
for my $i (@exclude) {
	if(ref($i) ne 'Regexp') {
		$i = qr/$i/
	}
}
for my $i (@iexclude) {
	if(ref($i) ne 'Regexp') {
		$i = qr/$i/i
	}
	Push(@exclude, $i)
}
@iexclude = ();

# Main Loop
my @DIR = ();
my %DIR = ();
my ($topdir, $topdirlen);
foreach my $currdir (@ARGV) {
	@DIR = ();
	%DIR = ();
	$topdir = $currdir;
	$topdir =~ s/$dirseptail//o;
	$topdirlen = length($topdir);
	next if($topdirlen <= 0);
	find({
		bydepth => 1,
		follows => $follow,
		follow_skip => 2,
		no_chdir => 1,
		dangling_symlinks => '',
		wanted => \&dotouch
	}, $currdir);
	@DIR = reverse(@DIR);
	foreach my $dir (@DIR) {
		my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,
			$atime, $mtime, $ctime, $blksize, $blocks) = ($follow ? stat($dir) : lstat($dir));
		my ($newatime, $newmtime) = @{$DIR{$dir}};
		if($force || ($atime != $newatime) || ($mtime != $newmtime)) {
			&touchit($newmtime, $newatime, $dir)
		}
	}
}

sub myctime ($) {
	my ($time) = @_;
	$time = localtime($time);
	return sprintf('%04d%02d%02d%02d%02d%s%02d',
		(1900 + $time->year()), 1 + $time->mon(), $time->mday(),
		$time->hour(), $time->min(), '.', $time->sec());
}

sub touchit ($$$) {
	my ($atime, $mtime, $file) = @_;
	my $cmtime = &myctime($mtime);
	return if($show && ($quiet >= 2));
	if((!$follow) && (-l $file)) {
		if($atime == $mtime) {
			&shprint('touch -h    -t ' . &shq($cmtime), $file) if($quiet < 2);
			system('touch', '-h', '-t', $cmtime, '--', $file) unless $show;
		} else {
			my $catime = &myctime($atime);
			&shprint('touch -h -m -t ' . &shq($cmtime), $file) if($quiet < 2);
			system('touch', '-h', '-m', '-t', $cmtime, '--', $file) unless $show;
			&shprint('touch -h -a -t ' . &shq($catime), $file) if($quiet < 2);
			system('touch', '-h', '-a', '-t', $catime, '--', $file) unless $show;
		}
		return
	}
	if($quiet < 2) {
		if($atime == $mtime) {
			&shprint('touch       -t ' . &shq($cmtime), $file)
		} else {
			my $catime = &myctime($atime);
			&shprint('touch    -m -t ' . &shq($cmtime), $file);
			&shprint('touch    -a -t ' . &shq($catime), $file);
		}
	}
	utime($atime, $mtime, $file) unless($show)
}

sub exclude ($) {
	my ($path) = @_;
	foreach my $regex (@exclude) {
		if($path =~ $regex) {
			return 1
		}
	}
	return ''
}

sub printcomment ($$) {
	my ($text, $dir) = @_;
	$dir =~  s/\n/\n\#\ /gom;
	printf("%s%-29s%s\n", '# ', $text, $dir)
}


sub dotouch () {
	if(-d $_) {
		return if($follow || !(-l $_));
	}
	if(substr($_, 0, $topdirlen) ne $topdir) {
		&printcomment("Prune:", $_);
		$File::Find::prune = 1;
		return
	}
	if(&exclude($_)) {
		&printcomment("Ignored:", $_) unless($quiet);
		return
	}
	my($dev, $ino, $mode, $nlink, $uid, $gid, $rdev, $size,
		$atime, $mtime, $ctime, $blksize, $blocks) = ($follow ? stat($_) : lstat($_));
	if($access && ($atime != $mtime)) {
		$atime = $mtime;
		&touchit($atime, $mtime, $_)
	} elsif($all) {
		&touchit($atime, $mtime, $_)
	}
	my $dirname = $File::Find::dir;
	while(length($dirname) >= $topdirlen) {
		if(exists($DIR{$dirname})) {
			my $array = $DIR{$dirname};
			my ($oriatime, $orimtime) = @$array;
			if($atime > $oriatime) {
				$array->[0] = $atime
			}
			if($mtime > $orimtime) {
				$array->[1] = $mtime
			}
		} else {
			push(@DIR, $dirname);
			$DIR{$dirname} = [ $atime, $mtime ]
		}
		last unless($dirname =~ s/$dirsepre/$1/o)
	}
}

sub shq ($) {
	my ($a) = (@_);
	$a =~ s/\'/\'\\\'\'/go; $a = "'$a'";
	$a =~ s/(^|[^\\])\'([\da-zA-Z\_\-\,\.\:\/]*)\'/$1$2/g;
	return(($a ne '') ? $a : "''");
}

sub shqs ($) {
	return(' ' . &shq($_[0]))
}

sub shdash {
	my($s, $r, $t) = (shift, '', '');
	for my $i (@_) {
		$t = 1 if($i =~ /^[-+]/);
		$r .= &shqs($i)
	}
	return (($t) ? ($s . ' --' . $r) : ($s . $r))
}

sub shprint {
	print(&shdash(@_), "\n")
}
