#!/usr/bin/perl -w
use strict;
use integer;
use Getopt::Long;
use Pod::Usage;
use File::Find;
use Fcntl ':mode';
use Time::localtime;
use File::stat;

my ($mdot,$ddot,$dirsep)=('.','..','/');

sub version () { '$Revision: 1.3 $ '=~ /Revision:\s([^\s]*)/;
  print "Touchdirs v$1 by Martin VÃ¤th\n"
   .    "martin\@mvath.de\n" ; exit 0 }

=head1 NAME

touchdirs - Touch directories according to their newest file

=head1 SYNOPSIS

B<touchdirs> [options] I<dirs>

=head1 DESCRIPTION

Look for all files in I<dirs> and then change all dirs' mtimestamps according
to the newest file contained (empty dirs' mtimestamps are ignored)

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--ignore=>I<regexp> or B<-i> I<regexp>

Ignore files whose (relative) path matches I<regexp>.

=item B<--ignore-case=>I<regexp> or B<-I> I<regexp>

Ignore files whose (relative) path matches I<regexp>, ignoring case.

=item B<--dotdirs> or B<-d>

Ignore .* dirs. Equivalent to B<--ignore=/\..*/> (needs quoting in shell)

=item B<--dotfiles> or B<-D>

Ignore .* files. Equivalent to B<--ignore=/\.[^/]*$> (needs quoting in shell)

=item B<--dot>

Ignore .* files/dirs. Equivalent to B<--ignore=/\.> or to B<-dD>

=item B<--git> or B<-g>

Ignore .git dirs. Equivalent to B<--ignore=/\.git/>

=item B<--follow-link> or B<-F>

Follow links to further directories.
Also use time of the file the link points to instead of time of the link.

=item B<--dry-run> or B<--show> or B<-n> or B<-s>

Only show what would be done, do not alter anything.

=item B<--version> or B<-V>

Print version number

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Default for the Options:

my $show='';
my $follow='';
my @exclude=();
my @iexclude=();

# Parse Options:

$Getopt::Long::bundling=1;
GetOptions(
  'help|h', sub { pod2usage(1) },
  'man|?', sub { pod2usage(-verbose=>2) },
  'version|V', \&version,
  'ignore|i=s', \@exclude,
  'ignore-case|I=s', \@iexclude,
  'dotdir|d', sub { push(@exclude,'/\..*/') },
  'dotfile|D', sub { push(@exclude,'/\.[^/]*$') },
  'dot', sub { push(@exclude,'/\.') },
  'git|g', sub { push(@exclude,'/\.git/') },
  'show|dry-run|s|n', \$show,
  'follow-link|F', \$follow,
  'nofollow-link', sub { $follow='' }
) or pod2usage(2);
($#ARGV>=0) or pod2usage(-verbose=>2);

my @DIR=();
my %DIR=();
foreach my $topdir (@ARGV)
{
  @DIR=();
  %DIR=();
  find({ bydepth=>1, follows=>$follow, wanted=>\&dotouch }, $topdir);
  @DIR=sort @DIR;
  @DIR=reverse @DIR;
  foreach my $dir (@DIR)
  {
    my $oritime=(($follow)?stat($dir)->mtime:lstat($dir)->mtime);
    my $newtime=$DIR{$dir};
    if($oritime ne $newtime)
    {
      my $time=ctime($newtime);
      &shprint('touch --date=' . &shq($time),$dir);
      unless($show) { system('touch',"--date=$time",'--',$dir) }
    }
  }
}

sub exclude ($) {
  my($path)=@_;
  foreach my $regex (@exclude) {
    if($path=~/$regex/) { return 1 }
  }
  foreach my $regex (@iexclude) {
    if($path=~/$regex/i) { return 1 }
  }
  return ''
}

sub dotouch () {
# if(($_ eq $mdot) || ($_ eq $ddot)) { return }
  if(-d $_) { return }
  my $path=$File::Find::dir . '/' . $_;
  if(&exclude($path)) {
    $path=~s/\n/\n\#\ /gom; print "# Ignored: $path\n"; return
  }
  my $time=(($follow)?stat($_)->mtime:lstat($_)->mtime);
  my $dirname=$File::Find::dir;
  while($dirname ne '')
  {
    if(exists($DIR{$dirname}))
    {
      my $oritime=$DIR{$dirname};
      if($time>$oritime)
        { $DIR{$dirname}=$time }
    }
    else
    {
      push(@DIR,$dirname);
      $DIR{$dirname}=$time
    }
    if($dirname=~/$dirsep/o)
    {
      $dirname=~/^(.*)$dirsep+/o;
      $dirname=$1;
    }
    else {last}
  }
}

sub shq ($) {
  my($a)=(@_);
  $a=~s/\'/\'\\\'\'/go; $a="'$a'";
  $a=~s/(^|[^\\])\'([\da-zA-Z\_\-\,\.\:\/]*)\'/$1$2/g;
  return(($a ne '') ? $a : "''");
}
sub shqs ($) { return ' ' . &shq($_[0]) }
sub shdash {
  my($s,$r,$t)=(shift,'','');
  for my $i (@_) { $t=1 if($i=~/^-/); $r.=&shqs($i) }
  return(($t) ? ($s . ' --' . $r) : ($s . $r))
}
sub shprint { print &shdash(@_) . "\n" }
