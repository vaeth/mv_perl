#!/usr/bin/env perl
require 5.012;
package Touchdirs v3.0.1;

use warnings;
use strict;
use integer;
no  sort 'stable';
use Getopt::Long 2.24 ();
use Pod::Usage ();
use File::Find ();
use File::Spec ();
use Time::localtime ();
#use Time::HiRes (); # needed unless -R is used

=head1 NAME

touchdirs - Touch directories according to their newest file

=head1 SYNOPSIS

B<touchdirs> [options] I<dirs>

=head1 DESCRIPTION

Look for all files in I<dirs> and then change all dirs' mtimestamps according
to the newest file contained (empty dirs' mtimestamps are ignored).
The used resolution of timestamps is one second, independent of the
properties of the filesystem.

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--round> or B<-r>

On filestamps with non-integer seconds, drop to integers and
modify recursed filestamps correspondingly.

=item B<--rounding>

On filestamps with non-integer seconds, drop to integers,
but do not touch non-directories only for this modification.

=item B<--roundread> or B<-R>

As B<--rounding> but do not even touch directories for the modification.

=item B<--force> or B<-f>

Touch dirs even if time did not change.
This has effects e.g. on copy-on-write filesystems or with B<--rounding>.

=item B<--all> or B<-a>

As B<--force> but additionally touch all files

=item B<--access> or B<-A>

Let access time be the same as modification time.

=item B<--ignore=>I<regexp> or B<-i> I<regexp>

Ignore files whose (relative) path matches I<regexp> (perl multiline regexp).

=item B<--ignore-case=>I<regexp> or B<-I> I<regexp>

Ignore files whose (relative) path matches I<regexp> (perl multiline regexp),
ignoring case.

=item B<--dotdirs> or B<-d>

Ignore .* dirs. Equivalent to B<--ignore=/\..+/>

=item B<--dotfiles> or B<-D>

Ignore .* files. Equivalent to B<--ignore=/\.[^/]+\z>

=item B<--dot>

Ignore .* files/dirs. Equivalent to B<--ignore=/\.> or to B<-dD>

=item B<--git> or B<-g>

Ignore .git dirs. Equivalent to B<--ignore=/\.git/>

=item B<--follow-link> or B<-F>

Follow links to further directories.
Also use time of the file the link points to instead of time of the link.

=item B<--quiet> or B<-q>

Do not print ignored directories.
If specified twice, do not print executed commands, either.

=item B<--check> or B<-c>

Check only whether Time::Hires seems to work correctly and then exit.
If combined with B<--quiet> do not output anything.

=item B<--dry-run> or B<--show> or B<-n> or B<-s>

Only show what would be done, do not alter anything.

=item B<--version> or B<-V>

Print version number

=back

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Options and their default:

my $check = '';
my $access = '';
my $force = '';
my $all = '';
my $round = '';
my $rounding = '';
my $roundread = '';
my $show = '';
my $follow = '';
my $quiet = 0;
my @exclude = ();
my @iexclude = ();

# Global Variables:

our $VERSION;
my $name = 'touchdirs';
my $hires_write;
my %DIR;
my $count;
my @topdirs;

# Functions:

sub not_equal {
	my ($a, $b) = @_;
	no integer;
	$a != $b
}

sub is_equal {
	my ($a, $b) = @_;
	no integer;
	$a == $b
}

sub myctime {
	my ($rtime) = @_;
	my ($time, $itime);
	my $hires_writing = '';
	my $arg = '-t';
	my $format = '%04d%02d%02d%02d%02d%s%02d%s';
	my $dot = '.';
	my $rest = '';
	if($hires_write) {
		$itime = int($rtime);
		$time = Time::localtime::localtime($itime);
		if(&not_equal($itime, $rtime)) {
			no integer;
			$hires_writing = 1;
			$rest = $rtime - $itime;
			$rest =~ s{^(?:[^\.]*)\.}{\.} or
				&fatal('strange number conversion');
			$arg = '-d';
			$format = '%04d-%02d-%02d %02d:%02d:%s%02d%s';
			$dot = ''
		}
	} else {
		$time = Time::localtime::localtime($rtime)
	}
	($hires_writing, $arg, sprintf($format,
		(1900 + $time->year()), 1 + $time->mon(), $time->mday(),
		$time->hour(), $time->min(), $dot, $time->sec(), $rest))
}

sub touchit {
	my ($atime, $mtime, $file) = @_;
	return if($show && ($quiet >= 2));
	my ($cm, $cmarg, $cmtime) = &myctime($mtime);
	if((!$follow) && (-l $file)) {
		if(&is_equal($atime, $mtime)) {
			&shprint("touch -h    $cmarg " . &shq($cmtime), $file) if($quiet < 2);
			system('touch', '-h', $cmarg, $cmtime, '--', $file) unless($show);
		} else {
			&shprint("touch -h -m $cmarg " . &shq($cmtime), $file) if($quiet < 2);
			system('touch', '-h', '-m', $cmarg, $cmtime, '--', $file) unless($show);
			my ($ca, $caarg, $catime) = &myctime($atime);
			&shprint("touch -h -a $caarg " . &shq($catime), $file) if($quiet < 2);
			system('touch', '-h', '-a', $caarg, $catime, '--', $file) unless($show);
		}
		return
	}
	if(&is_equal($atime, $mtime)) {
		&shprint("touch       $cmarg " . &shq($cmtime), $file) if($quiet < 2);
		if($cm && !$show) {
			system('touch', $cmarg, $cmtime, '--', $file);
			return
		}
	} else {
		my ($ca, $caarg, $catime) = &myctime($atime);
		&shprint("touch    -m $cmarg " . &shq($cmtime), $file) if($quiet < 2);
		my $system = ((!$show) && ($cm || $ca));
		system('touch', '-m', $cmarg, $cmtime, '--', $file) if($system);
		&shprint("touch    -a $caarg " . &shq($catime), $file) if($quiet < 2);
		if($system) {
			system('touch', '-a', $caarg, $catime, '--', $file);
			return
		}
	}
	utime($atime, $mtime, $file) unless($show)
}

sub exclude {
	my ($path) = @_;
	for my $regex (@exclude) {
		if($path =~ $regex) {
			return 1
		}
	}
	''
}

sub printcomment {
	my ($text, $dir) = @_;
	$dir =~ s{\n}{\n\#\ }gm;
	printf("%s%-29s%s\n", '# ', $text, $dir)
}

sub my_split {
	my ($arr, $dir) = @_;
	@$arr = File::Spec->splitdir($dir)
}

sub my_cat {
	File::Spec->catdir(@_)
}

sub my_amtime {
	my ($file) = @_;
	(((!$follow) && (-l $file)) ?
		($roundread ? lstat($file) : Time::HiRes::lstat($file)) :
		($roundread ? stat($file) : Time::HiRes::stat($file)))[8, 9]
}

sub dotouch {
	if(-d $_) {
		return if($follow || !(-l $_));
	}
	if(&exclude($_)) {
		&printcomment("Ignored:", $_) unless($quiet);
		return
	}
	my @dirs;
	&my_split(\@dirs, $_);
	for my $i (@topdirs) {
		if((!@dirs) || ($i ne shift(@dirs))) {
			&printcomment("Prune:", $_);
			$File::Find::prune = 1;
			return
		}
	}
	my $filename = &my_cat(@topdirs, @dirs);
	my ($atime, $mtime) = &my_amtime($filename);
	my $write = $all;
	if($rounding) {
		my ($oldatime, $oldmtime) = ($atime, $mtime);
		($atime, $mtime) = (int($atime), int($mtime));
		if($round) {
			$write = 1 if(&not_equal($oldatime, $atime) || &not_equal($oldmtime, $mtime))
		}
	}
	if($access && &not_equal($atime, $mtime)) {
		$atime = $mtime;
		&touchit($atime, $mtime, $filename)
	} elsif($write) {
		&touchit($atime, $mtime, $filename)
	}
	while(@dirs) {
		pop(@dirs);
		my $dirname = &my_cat(@topdirs, @dirs);
		my $array = $DIR{$dirname};
		if(defined($array)) {
			my ($oriatime, $orimtime) = @$array;
			if($atime > $oriatime) {
				$array->[0] = $atime
			}
			if($mtime > $orimtime) {
				$array->[1] = $mtime
			}
		} else {
			$DIR{$dirname} = [ $atime, $mtime, scalar(@dirs), $count++ ]
		}
	}
}

sub shq {
	my ($a) = (@_);
	$a =~ s{\'}{\'\\\'\'}g;
	$a = "'$a'";
	$a =~ s{(\A|[^\\])\'([\w\-\,\.\:\/]*)\'}{$1$2}gm;
	(($a ne '') ? $a : "''")
}

sub shqs {
	' ' . &shq($_[0])
}

sub shdash {
	my ($s, $r, $t) = (shift, '', '');
	for my $i (@_) {
		$t = 1 if($i =~ m{^[-+]});
		$r .= &shqs($i)
	}
	($t) ? ($s . ' --' . $r) : ($s . $r)
}

sub shprint {
	print(&shdash(@_), "\n")
}

sub info {
	print("$name: ",
		join("\n" . (' ' x (length($name) + 2)), @_), "\n");
}

sub warning {
	print(STDERR "$name: warning: ",
		join("\n" . (' ' x (length($name) + 11)), @_), "\n");
}

sub fatal {
	print(STDERR "$name: fatal: ",
		join("\n" . (' ' x (length($name) + 9)), @_), "\n");
	exit(1)
}

sub version {
	print($name . ' ' . $VERSION->stringify() . "\n");
	exit(0)
}

# Parse Options:

Getopt::Long::Configure(qw(bundling gnu_compat));
Getopt::Long::GetOptions(
	'help|h', sub { Pod::Usage::pod2usage(1) },
	'man|?', sub { Pod::Usage::pod2usage(-verbose => 2) },
	'version|V', \&version,
	'round|r', \$round,
	'rounding', \$rounding,
	'roundread|R', \$roundread,
	'force|f', \$force,
	'all|a', \$all,
	'access|A', \$access,
	'ignore|i=s', \@exclude,
	'ignore-case|I=s', \@iexclude,
	'dotdir|d', sub { push(@exclude, qr{/\..+/}m) },
	'dotfile|D', sub { push(@exclude, qr{/\.[^/]+\z}m) },
	'dot', sub { push(@exclude, qr{/\.}) },
	'git|g', sub { push(@exclude, qr'{\.git}') },
	'show|dry-run|s|n', \$show,
	'quiet|q+', \$quiet,
	'check|c', \$check,
	'follow-link|F', \$follow,
	'nofollow-link|no-follow-link', sub { $follow = '' }
) or Pod::Usage::pod2usage(2);
Pod::Usage::pod2usage(-verbose => 2) unless($check || @ARGV);

# Set dependent options
$rounding = 1 if($round || $roundread);
if($all) {
	$force = 1;
	$round = ''
}
if($check) {
	$roundread = '';
	$follow = 1
}

# Set globals depending on options
$hires_write = !$rounding;
unless($roundread) {
	eval {
		require Time::HiRes
	};
	if($@) {
		my @err = ('perl module Time::HiRes not found:', $@);
		if($check) {
			&info(@err) unless($quiet);
			exit(1)
		}
		&warning(@err, 'Forcing option -R');
		$roundread = 1
	} else {
		my ($atime, $mtime) = &my_amtime(File::Spec->curdir());
		if((int($atime) < 1000000) || (int($mtime) < 1000000)) {
			my @err = ('Time::Hires::stat() appears broken');
			if($check) {
				print(@err) unless($quiet);
				exit(1)
			}
			$roundread = 1;
			($atime, $mtime) = &my_amtime(File::Spec->curdir());
			&fatal('stat() appears to be corrupted by Time::Hires',
				'You might want to retry with option -R')
				if(($atime < 1000000) ||
					(int($mtime) < 1000000));
			&warning(@err, 'Forcing option -R')
		} elsif($check) {
			&info('Time::Hires appears to work')
				unless($quiet);
			exit(0)
		}
	}
	if($roundread) {  # error case
		$round = '';
		$rounding = 1
	}
}

# Compile regular expressions and make one array:
for my $i (@exclude) {
	$i = qr{$i}m if(ref($i) ne 'Regexp')
}
for my $i (@iexclude) {
	$i = qr{$i}im if(ref($i) ne 'Regexp');
	Push(@exclude, $i)
}
@iexclude = undef;

# Main Loop
for my $currdir (@ARGV) {
	%DIR = ();
	$count = 0;
	&my_split(\@topdirs, File::Spec->canonpath($currdir));
	my $topdir = &my_cat(@topdirs);
	unless(-d $topdir) {
		$_ = $topdir;
		&dotouch();
		next
	}
	File::Find::find({
		bydepth => 1,
		follows => $follow,
		follow_skip => 2,
		no_chdir => 1,
		dangling_symlinks => '',
		wanted => \&dotouch
	}, $topdir);
	my @DIR = sort {
		my $x = $DIR{$a};
		my $y = $DIR{$b};
		($y->[2] cmp $x->[2]) || ($y->[3] cmp $x->[3])
	} keys(%DIR);
	for my $dir (@DIR) {
		my ($atime, $mtime) = &my_amtime($dir);
		my ($newatime, $newmtime) = @{$DIR{$dir}};
		if($force || &not_equal($atime, $newatime) ||
			&not_equal($mtime, $newmtime)) {
			&touchit($newmtime, $newatime, $dir)
		}
	}
}
1;
