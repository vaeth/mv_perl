#!/usr/bin/env perl
BEGIN { require 5.008 }
package Patchdirs;
our $VERSION = 'v3.2.3';
eval { $VERSION = version->declare($VERSION) };
eval 'use version 0.77; $VERSION = version->declare($VERSION)' if($@);

use warnings;
use strict;
use integer;
use Getopt::Long 2.24 ();
use File::Find ();
use File::Spec ();
use Fcntl ();
use Time::localtime ();
#use Digest::MD5 ();
#use String::Escape ();  # not mandatory but strongly recommended: poor fallback
#use String::ShellQuote ();  # not mandatory but recommended: poor fallback
#use Pod::Usage ();  # needed for --man, --help, some errors

=encoding UTF-8

=head1 NAME

patchdirs - calculate checksums, patch directory structure, look for duplicates

=head1 SYNOPSIS

There are three modes of calling:

=over 8

=item B<patchdirs> [options] B<store> I<dirs> B<E<gt>>I<destlist>

=item B<patchdirs> [options] B<restore> I<destlist>

=item B<patchdirs> [options] B<double> I<dirs>

=back

Instead of the keywords B<store> B<restore> B<double>
also one of the options B<--store> B<--restore> B<--double>
can be specified to choose the mode.

Options B<--man> (or B<-?>) or B<--help> (or B<-h>)
give an explicit help as a manpage or an ascii-text, respectively.

=head1 DESCRIPTION

In B<store> mode, the directories I<dirs> are listed recursively, together
with MD5-checksum, length, attributes, owner/group, and (modification) dates.
The output is meant to be redirected to some file. (Note that you can modify
this file or use options to add/subtract times to "reconstruct" a different
tree later on).

The B<restore> mode can be used to keep two different filesystems in sync
(without a direct connection) or to restore an older state of the filesystem.
In this mode, the argument I<destlist> should be the file (or several files)
created in B<store> mode on the original filesystem.
The directory structure of the current filesystem is then modified to match
I<destlist> as far as possible:
This includes creation of directories and symbolic links and
moving/renaming/copying/deletion of already existing files and
changing of mod/owner/dates. To recognize identical files, the checksum
information is used (and only if it is equal a heuristic is used).
  Of course, no new files can be created from the checksum information alone:
A list of missing files (compared to I<destlist>) is output at the end.
I took much care that the restoration works fine even if filenames have been
swapped in a circular way or exchanged with directory names.
  Of course, I give no guarantee that all special cases are treated correctly.
However, the command is written in a way that the actual changes are the last
thing which is done: Thus, if the program exits with a "normal" error,
no changes to the filesystem have been done so far. I recommend to run this
mode first with the B<-n> option and to glance through the output before
doing the actual run. If long directories are to be considered and so the
calculation of checksums takes a considerable amount of time, I recommend
also to scan the current directory structure first in B<store> mode and to
read the checksum information only with the B<-f> switch.

The B<double> mode can be used to find duplicate files:
All files which are double in I<dirs> (according to the checksum) are listed.
If more than two files are duplicate, they all occur on the same line of
output. Each line and also the list of lines is sorted alphabetically.
If you frequently have to compare new files against a fixed directory tree,
this call is very useful in conjunction with the B<-f> option.
Note that if you want to "update" an older I<destlist> and you have only
added new files you can use the B<-f> option also for store mode
to save a lot of time.

=head1 OPTIONS AND ARGUMENTS

=over 8

=item B<--file=>I<file> or B<-f> I<file>

In addition (for B<store> or B<double> mode) respectively instead
(for B<restore> mode) of getting the actual tree structure (with checksums)
by recursing through the directories, the required data
(filenames/checksums/modes/...) is read from I<file>.
I<file> might have been obtained by an earlier call in B<store> mode.

This has two purposes:

=over 4

=item 1.

It is I<very> fast, since no checksums have to be calculated -
use it if you frequently have to compare files against a fixed
directory tree.

=item 2.

You might use this feature to I<hide> from the program the
existence of certain files (manipulate I<file> by hand).

=back

It is explicitly admissible to use this option repeatedly:
The I<file>s are then concatenated. It is also admissible
to pass a comma separated list of filenames to this option.
As usual in Perl, if a filename is "-", standard input is used instead.
If a filename occurs more than once within <file>, always the first
occurence of this name is assumed to be the correct one.
(In particular, if a file listed for B<double> mode occurs in
I<file>, then its checksum is I<never> calculuted, even if
it occurs in I<dirs>).

=item B<--files=>I<file1> I<file2> ...  or B<-i> I<file1> I<file2> ...

Synonymous to B<--file> I<file1> B<--file> I<file2> ...

The advantage over the B<--file> option is that this works perfectly
with the shell pattern expansion. For example (if you work with a usual
unix shell) you can use B<--files *.pds> to read all files matching
the pattern B<*.pds>.

A disadvantage compared to the B<--file> option is that another option
(starting with the character B<->) B<must> follow to mark the end of
the list; if you have no other option to follows the list, you B<must> use
B<--> to mark the end of the options.

Obviously, it is not possible with this option to use a filename starting
with the character B<-> (the only exception is the name B<-> itself
which has the usual magic meaning).

As with B<--file>, the character B<,> is considered as a separation character
for several names.

=item B<--hint=>I<file> or B<-h> I<file>

This is similar to B<--file=>I<file>, but the information of I<file> is only
used to take the checksum if filename and filesize do match.
In other words: In contrast to B<--file>, a file listed in I<file>
is not treated as if it would exist.

=item B<--hints=>I<file1> I<file2> ...  or B<-I> I<file1> I<file2> ...

Synonymous to B<--hint> I<file1> B<--hint> I<file2> ...

=item B<--sum-cmds=>I<cmds> or B<-S> I<cmds>

You may list several checksum-commands in I<cmds>, separated by ";".
For each of the commands in I<cmds>, "command I<filename>" is
executed in the directory where filename resides.
It is expected that command prints the checksum to standard
output (possibly followed by some other data after a whitespace).
If several commands are listed, each one is executed and the actual checksum
is built by concatenating the outputs of the programs with ":".
The command "." is magic and means that the Perl package
B<Digest::MD5> is used. The size of the file is always automatically the first
"checksum".

=over 4

=item Example: --sum-cmds='.;cksum;sum;sum -s'

will concatenate the checksums of B<Digest::MD5>
and of the standard unix commands "cksum I<name>", "sum I<name>",
and "sum -s I<name>". This example creates an extremely long
(slow but secure) checksum.

=back

The default is --sum-cmds='.' which means that only
B<Digest::MD5> is used (which is reasonably secure and fast).

=item B<--strip=>I<num> or B<-p> I<num>

Cut the first I<num> "/" from the directory names in the filenames read from
I<destlist> or with the B<-f> option.
For B<restore> mode (without the B<-f> option), I<num>E<gt>0 means
that only the filenames of I<destfile> are stripped and automatically the
current directory and I<all> its subdirectories are considered as the current
directory structure. (Treat with care: Recall that all files not
existing in I<destfile> are deleted by default).
If I<num>E<lt>0, then "../" is prepended -I<num> times.

=item B<--output-strip=>I<num> or <-P> I<num>

Cut the first I<num> "/" from the directory names in the filenames output in
B<store> mode. Note that <num>=1 usually has no effect, because only "./" is
stripped which is prepended again for clarity.
If I<num>E<lt>0, then "../" is prepended -I<num> times.

=item B<--dry-run> or B<-n>

Only show what would be done, do not alter anything.

=item B<--show> or B<-s>

Same as -n

=item B<--delete> or B<-d>

Delete files/dirs not in DESTLIST (default)

=item B<--owner> or B<-o>

Modify owner/group (default)

=item B<--attrib> or B<-a>

Modify permission attributes (default)

=item B<--time> or B<-t>

Modify modification time (default)

=item B<--copy> or B<-z>

Duplicate files if this appears appropriate (default)

=item B<--checksum> or B<-c>

Calculate checksum (default).

=item B<--recurse> or B<-r>

Recurse (default)

=item B<--justintime> or B<-j>

Calculate checksums immediately during directory scanning.
This is more safe if directories change during scanning.
The disadvantage is that no total number of files or size percentage is output.

=item B<--follow-link> or B<-F>

Follow symbolic links (loops are avoided)

=item B<--addseconds=>I<num>

Add I<num> seconds when reading the time of a file (useful for FAT partitions)

=item B<--subseconds=>I<num>

Sub I<num> seconds when reading the time of a file (useful for FAT partitions)

=item B<--upper> or B<-u>

Make all names uppercase (useful for FAT partitions)

=item B<--lower> or B<-l>

Make all names lowercase (useful for FAT partitions)

=item B<--nodelete> or B<-D>

Do not delete any files/dirs

=item B<--noowner> or B<-O>

Do not modify owner/group

=item B<--noattrib> or B<-A>

Do not modify permission attributes

=item B<--notime> or B<-T>

Do not modify modification time

=item B<--nocopy> or B<-Z>

Do not duplicate files

=item B<--nochecksum> or B<-C>

Do not calculate checksum.
This makes sense only for B<store> mode and also then is not very useful...

=item B<--norecurse> or B<-R>

Do not recurse, i.e. use only the explicitly given dirs

=item B<--nofollow-link>

Do not follow symbolic links (default)

=item B<--noupper> or B<-U>

Do not make all names uppercase (default)

=item B<--nolower> or B<-L>

Do not make all names lowercase (default)

=item B<--force>

If ambiguity occurs: Do not stop but instead move first candidate

=item B<--verbose> or B<-v>

Be verbose. This can be specified accumulatively

=item B<--quiet> or B<-q>

Be quiet. This can be specified accumulatively

=item B<--version> or B<-V>

Print version number

=back

The options B<-O> B<-A> B<-T> B<-C> in B<store> mode create an output
which might be better readable by humans, since it contains less data.
However, a file created in B<store> mode with these options, should only
be used (with B<--file> or for B<restore> or B<double> mode) if the same
options are repeated. Moreover, option B<-C> must not be used for
B<restore> or B<double> mode.

Mnemonic: B<-TAO> is only ok if you repeat the mantra.

=head1 AUTHOR

Martin VE<auml>th E<lt>martin@mvath.deE<gt>

=cut

# Static variables:

my $name = 'patchdirs';
my $mdot = File::Spec->curdir();
my $ddot = File::Spec->updir();

# Global Variables:

my $umask = undef;
my @A = ();
my %Afullname = ();
my @Adirs = ();
my @B = ();
my %Bfullname = ();
my %Bcheck = ();

# Default for the Options:

my $outstrip = 0;
my $strip = 0;
my $force = '';
my $quiet = 0;
my $verbose = 0;
my $show = '';
my $follow = '';
my $dodelete = 1;
my $modowner = 1;
my $modattrib = 1;
my $modtime = 1;
my $dupcopy = 1;
my $calccheck = 1;
my $sumcmds = '.';
my @sumcmds;
my $upper = '';
my $lower = '';
my @files = ();
my @hints = ();
my $recurse = 1;
my $justintime = '';
my $mode = '';
my $addseconds = 0;
my $subseconds = 0;

# Functions:

sub shdash {
	my $c = shift();
	$c = [$c] unless(ref($c) eq 'ARRAY');
	for my $i (@_) {
		if($i =~ m{^[-+]}o) {
			push(@$c, '--');
			last
		}
	}
	(@$c, @_)
}

# use String::ShellQuote () and return whether successful

{ my $shellquote = undef;  # A closure static variable
sub use_shellquote {
	return $shellquote if(defined($shellquote));
	eval {
		require String::ShellQuote
	};
	$shellquote = !$@
}}

# use String::Escape () and return whether successful

{ my $escape = undef;  # A closure static variable
sub use_escape {
	return $escape if(defined($escape));
	eval {
		require String::Escape
	};
	$escape = !$@
}}

# like join(' ', @_), but shell-quote arguments

sub join_quoted {
	my @r;
	for my $i (@_) {
		my $a = $i;
		$a =~ s{\'}{\'\\\'\'}g;
		$a = "'$a'";
		$a =~ s{(\A|[^\\])\'([\w\-\,\.\:\/]*)\'}{$1$2}gm;
		push(@r, ($a ne '') ? $a : "''")
	}
	join(' ', @r)
}

sub shell_quote_best_effort {
	(&use_shellquote() ?
		&String::ShellQuote::shell_quote_best_effort : &join_quoted)
}

sub shell_dash {
	&shell_quote_best_effort(&shdash)
}

sub list2string {
	(&use_escape() ? &String::Escape::list2string : &join_quoted)
}

sub split_quoted {
	my $arg = shift();
	my @res = ();
	my $word = undef;
	my $quoting = '';
	$_[0] = '' if(@_);
	while($arg ne '') {
		my $add;
		if(($arg =~ s{\A([^\"\'\s\\]+)}{}m) ||
			($arg =~ s{\A\\(.)}{}m) ||
			($arg =~ s{\A\'((?:[^\'])*)\'}{}m)) {
			$add = $1
		} elsif($arg =~ s{\A(\s+)}{}m) {
			$add = $1;
			unless($quoting) {
				if(defined($word)) {
					push(@res, $word);
					$word = undef
				}
				next
			}
		} elsif($arg =~ s{^\"}{}) {
			$quoting = !$quoting;
			next
		} elsif($arg eq "\\") {
			$_[0] = "file ends with \\-quote" if(@_);
			return @res
		} elsif($arg =~ s{\A\'}{}m) {
			$_[0] = "unclosed \'-quote" if(@_);
			$add = $arg;
			$arg = ''
		}
		if(defined($word)) {
			$word .= $add
		} else {
			$word = $add
		}
	}
	$_[0] = "unclosed \"-quote" if($quoting && @_);
	push(@res, $word) if(defined($word));
	@res
}

sub string2list {
	(&use_escape() ? &String::Escape::string2list : &split_quoted)
}


# split dir into volume and directory components

sub split_dir {
	my ($vol, $dir, $file) = File::Spec->splitpath(File::Spec->canonpath($_[0]));
	my @dir = File::Spec->splitdir($dir);
	pop(@dir) if(@dir && $dir[$#dir] eq '');
	push(@dir, $file) if($file ne '');
	($vol, @dir)
}

# compose dir/file from volume and directory components

sub cat_dir {
	my $vol = shift;
	my $file = pop;
	File::Spec->catpath($vol, File::Spec->catdir(@_), $file)
}

sub strip_dirs {
	my $num = shift();
	return 1 unless($num);
	my ($vol, @dirs) = &split_dir($_[0]);
	if($num < 0) {
		$_[0] = &cat_dir($vol, (($ddot) x (-$num)), @dirs);
		return 1
	}
	if(@dirs > $num) {
		$_[0] = &cat_dir($vol, splice(@dirs, 0, $num));
		return 1
	}
	&warning("ignoring $name",
		'it contains less directories than you want to strip');
	''
}

sub info {
	my $add = ': ';
	print(STDERR $name, $add,
		join("\n" . (' ' x (length($name) + length($add))), @_), "\n")
}

sub warning {
	my $add = ': warning: ';
	print(STDERR $name, $add,
		join("\n" . (' ' x (length($name) + length($add))), @_), "\n")
}

sub error {
	my $add = ': error: ';
	print(STDERR $name, $add,
		join("\n" . (' ' x (length($name) + length($add))), @_), "\n")
}

sub fatal {
	my $add = ': fatal: ';
	print(STDERR $name, ': fatal: ',
		join("\n" . (' ' x (length($name) + length($add))), @_), "\n");
	exit(1)
}

sub version {
	print($name, ' ', $VERSION, "\n");
	exit(0)
}

sub pod2usage {
	require Pod::Usage;
	&Pod::Usage::pod2usage
}


sub standardlist {
	@ARGV = ($mdot) unless(@ARGV || @files);
	@A = ();
	%Afullname = ();
	&readlist(\@files, \@A, \@Adirs, \%Afullname) if(@files);
	&makelist(\@A, \%Afullname, \@ARGV) if(@ARGV)
}

{
	my ($halfm, $fullm, $thousand5, $ten);
{
	use bigint;
	$halfm = 512 * 1024;
	$fullm = 1024 * 1024;
	$thousand5 = 1005;
	$ten = 10
}
sub infocount {
	return if($quiet);
	my ($countref, $total, $size, $name) = @_;
	my $counter = ++($countref->[0]);
	my $info = (@$total ? $counter . '|' . $total->[0] . ' ' :
		$counter . ': ');
	my $printsize;
	{
		use bigint;
		my $currsize = $countref->[1];
		$printsize = (($currsize + $halfm) / $fullm) . 'M + ' .
			(($size + $halfm) / $fullm) . 'M';
		$countref->[1] += $size;
		if(@$total) {
			my $totalsize = $total->[1];
			my $percent = ($totalsize ?
				(($currsize * $thousand5) / $totalsize) / $ten
				: 100);
			$info .= sprintf((($percent >= 100) ? '%03u' : ' %02u'),
				$percent) . '%: '
		}
	}
	&info('[' . $info . $printsize . '] Checksumming ' . $name)
}}

sub checksum {
	my $name = shift();
	my $errname = (shift() // $name);
	my @checksum = ();
	for my $cmd (@sumcmds) {
		if($cmd eq '.') {
			open(my $file, '<', $name) or
				&fatal("cannot open $errname", $!);
			binmode($file);
			push(@checksum, Digest::MD5->new->addfile($file)->b64digest());
			close($file)
		} elsif($cmd ne '') {
			my $c = &shell_dash($cmd, $_);
			$c = `$c`;
			$c =~ m{([^\s]+)*};
			push(@checksum, $1)
		}
	}
	(@checksum)
}

{
	my %hints = ();
	my $know_hints = '';
sub hintchecksum {
	my ($name, $size) = @_;
	my $checksum = $hints{$name};
	return undef unless(defined($checksum));
	if($checksum =~ m{^(\d+)}o) {
		return $checksum if($size == $1)
	}
	undef
}
sub makelist {
	my ($list, $fullhash, $dirs) = @_;
	if(@hints) {
		&readlist(\@hints, \%hints);
		@hints = ()
	}
	my @count  = (0, 0);
	my @postpone = ();
	my @total = $justintime ? () : (0, 0);
	my $fullpath;
	my $makeentry = sub {
		return if(($_ eq $mdot) || ($_ eq $ddot));
		$File::Find::prune = 1 unless($recurse);
		my $name = ($fullpath ? $_ :
			&unify_name((&cat_dir(&split_dir($File::Find::dir), $_))));
		my ($mode, $uid, $gid, $size, $mtime) =
			($follow ? (stat($_)) : (lstat($_)))[2, 4, 5, 7, 9];
		unless(defined($mtime)) {
			&info("cannot stat $name");
			return
		}
		return if(defined($fullhash->{$name}));
		my $checksum;
		if(Fcntl::S_ISLNK($mode)) {
			my $linkname = readlink();
			$checksum = '->' . $linkname
		} elsif(Fcntl::S_ISDIR($mode)) {
			$checksum = 'dir'
		} elsif(Fcntl::S_ISREG($mode)) {
			$checksum = &hintchecksum($name, $size);
			if(defined($checksum)) {
				&info('hinted checksum for ' . $name)
					if($verbose)
			} elsif($calccheck) {
				if($justintime) {
					&infocount(\@count, \@postpone, $size, $name);
					$checksum = join(':', $size, &checksum($_, $name))
				} else {
					$checksum = $size;
					push(@postpone, scalar(@$list));
					use bigint;
					$total[1] += $size;
				}
			} else {
				$checksum = $size
			}
		} else {
			$checksum = sprintf("other:%x", Fcntl::S_IFMT($mode))
		}
		$mode = sprintf("%04o", Fcntl::S_IMODE($mode));  # $mode & 07777
		my $time = Time::localtime::ctime($mtime + $addseconds);
		$fullhash->{$name} = scalar(@$list);
		push(@$list, [ $name, $checksum, $mode, $uid . ':' . $gid, $time ])
	};

	my @mydirs = ();
	for my $a (@$dirs) {
		my $b = &unify_name($a);
		push(@mydirs, $b) if(-d $b)
	}
	return unless(@mydirs);
	@mydirs = sort(@mydirs);

	$fullpath = 1;
	for (@mydirs) {
		$makeentry->()
	}
	$fullpath = '';

	File::Find::find({
		follow_fast => $follow,
		preprocess => sub {
			&info('scanning directory ' . $File::Find::dir)
				unless($quiet);
			(sort(@_))
		},
		wanted => $makeentry
	}, @mydirs);
	return unless(@postpone);

	$total[0] = scalar(@postpone);
	for my $index (@postpone) {
		my $curr = \@{$list->[$index]};
		my ($name, $size) = @$curr;
		&infocount(\@count, \@total, $size, $name);
		$curr->[1] = join(':', $size, &checksum($name))
	}
}}

sub printlist {
	my ($list) = @_;
	for my $f (@$list) {
		my ($name, $checksum, $mode, $owner, $time) = @$f;
		next unless(&strip_dirs($outstrip, $name));
		print(&list2string($name, $checksum,
			($modattrib ? $mode : ()),
			($modowner ? $owner : ()),
			($modtime ? $time : ())), "\n")
	}
}

sub readlist {
	my ($files, $list, $alldirs, $fullhash);
	my $only_checksum;
	if(@_ > 2) {
		($files, $list, $alldirs, $fullhash) = @_;
		$only_checksum = ''
	} else {
		($files, $fullhash) = @_;
		$only_checksum = 1
	}
	my %hashdir = ();
	my $repeat = undef;
	my $err;
	for my $file (@$files) {
		my ($fh, $close);
		if($file eq '-') {
			$fh = \*STDIN;
			$close = ''
		} else {
			unless(open($fh, '<', $file)) {
				&warning("cannot open $file");
				next
			}
			$close = 1
		}
		while(<$fh>) {
			chomp();
			if(defined($repeat)) {
				$repeat .= "\n" . $_
			} elsif((m{^\s*$}) || (m{^\s*[\#\;]})) {
				next
			}
			my ($name, $checksum, $mode, $owner, $time) =
				&string2list($repeat // $_);
			$repeat = undef;
			$name = &unify_name($name);
			next unless(&strip_dirs($strip, $name));
			&fatal("no checksum for $name") unless(defined($checksum));
			my ($vol, @dirs) = &split_dir($name);
			my $file = pop(@dirs);
			unless(@dirs) {
				@dirs = ($mdot);
				$name = &cat_dir(@dirs, $file)
			}
			if(exists($fullhash->{$name})) {
				&warning("ignoring second occurence of $name");
				next
			}
			if($only_checksum) {
				if($checksum =~ m{^\d+\:.}) {
					$fullhash->{$name} = $checksum
				}
				next
			}
			$hashdir{&cat_dir($vol, @dirs)} = '';
			($owner, $time) = ($mode, $owner) unless($modattrib);
			$time = $owner unless($modowner);
			unless($quiet) {
				&warning("-T assumed for $name") if($modtime && !defined($time));
				&warning("-A assumed for $name") if($modattrib && !defined($mode));
				&warning("-O assumed for $name") if($modowner && !defined($owner))
			}
			$fullhash->{$name} = scalar(@$list);
			push(@$list, [ $name, $checksum, $mode, $owner, $time ])
		}
		close($fh) if($close)
	}
	return if($only_checksum);
	@$alldirs = keys(%hashdir)
}

sub unify_name {
	my ($name) = @_;
	$name = File::Spec->canonpath($name);
	$upper ? uc($name) : ($lower ? lc($name) : $name)
}

sub make_check {
	my ($list, $check) = @_;
	%$check = ();
	while(my ($j, $ref) = each(@$list)) {
		my ($name, $checksum, $mode, $owner, $time) = @$ref;
		$check->{$checksum} = [] unless(defined($check->{$checksum}));
		push(@{$check->{$checksum}}, $j);
	}
}

{  # Patch

my ($tolink, @not_exist, %from_name);
my (@mkdir_cmds, @link_cmds, @mov_cmds, @copy_cmds, @del_cmds, @rmdir_cmds);
my (@after_rmdir_cmds, @mod_cmds);
my (@copy_list, %needed_dir, @deleted_index);
sub patchlist () {
	my $willdie = '';
	@not_exist = ();  # List of missing files
	%from_name = ();  # Index: File to move. Content: Where to move.
	@mkdir_cmds = ();
	@link_cmds = ();
	@mov_cmds = ();
	@copy_cmds = ();
	@del_cmds = ();
	@rmdir_cmds = ();
	@after_rmdir_cmds = ();
	@mod_cmds = ();
	@copy_list = ();  # Content: Two-element-array(reference):
	                  #          From(as index), To(as name)
	%needed_dir = ();  # Directories which implicitly exist in a pathname
	@deleted_index = ();
	$#deleted_index = $#B;  # Did we decide to move this file?

	# Pass 1: We decide which files to move where (collect into %from_name).
	#         Also build @mod_cmds, @LinkCmd, @mkdir_cmds, @copy_list, @not_exist,
	#         @deleted_index,%needed_dir.
	while(my ($i, $f) = each(@A)) {
		#if(($i % 50) == 0) { print STDERR "." }
		my ($Aname, $Achecksum, $Amode, $Aowner, $Atime) = @$f;
		if(&isordinary($Achecksum)) {
			my $sumarr = $Bcheck{$Achecksum};
			if(defined($sumarr)) {   # We have a file with the required checksum for $f
				my $move = 1;
				my @movecand = ();     # Optimal move candidates
				my @movecandsub = ();  # Suboptimal move candidates
				for my $j (@$sumarr) {  # For all existing files $g with this checksum
					next if($deleted_index[$j]);  # (Only if this file has not been moved)
					my $g = $B[$j];
					my ($Baname, $Bchecksum) = @$g;
					my $ia = $Afullname{$Baname};
					if(defined($ia)) {  # Some file should stay at $g's place.
						if($ia != $i) {  # If this file is differrent than $f and ...
							my $fa = $A[$ia];
							my ($Aaname, $Aachecksum, $Aamode, $Aaowner, $Aatime) = @$fa;
							if($Aachecksum ne $Bchecksum) {  #...if this file has another checksum
								push(@movecandsub, $j)  # -> $g is candidate for moving
							}
							# If it has the same checksum, we assume that it cannot be moved
						} else {  # This is the same file as $f: No moving required
							$move = '';
							@movecand = ($j);
							@movecandsub = ();
							last
						}
					} else { # $g should even be deleted -> very good candidate
						push(@movecand, $j)
					}
				}
				if(($#movecand < 0) && ($#movecandsub < 0)) {
					# Although we have files with a matching checksum, each of these
					# files already appears to be on the right place or has already
					# been moved to the right place.
					if($dupcopy) {
						my ($isnew, $j) = &make_dirs_for($Aname, $Achecksum);
						if($isnew) {
							$j = $sumarr->[0];
							push(@copy_list, [$j, $Aname]);
						}
						&changemods($Aname, $Amode, $Aowner, $Atime, '', $isnew, $j);
					} else {
						push(@not_exist, $f)
					}
				} else {
					my $j;                # Index of chosen movecandidate
					my $morecand = '';    # More than 1 candidate -> print an error/warning.
					if($#movecand == 0) { # There is precisely one optimal:
						$j = $movecand[0]
					} else {
						push(@movecand, @movecandsub);
						if(@movecand == 1) {  # There is precisely one (sub)optimal
							$j = $movecand[0]
						} else {  # There is some ambiguity.
							  # In this case, we decide by the name
							my @name = ();
							my @namesub = ();  # suboptimal (case insensitive) matching
							for my $jt (@movecand) {
								my $g = $B[$jt];
								my ($Bname) = @$g;
								my $Abase = &basename($Aname);
								my $Bbase = &basename($Bname);
								if(($Abase ne '') && ($Bbase ne '')) {
									if($Abase eq $Bbase) {
										push(@name, $jt)
									} elsif(uc($Abase) eq uc($Bbase)) {
										push(@namesub, $jt)
									}
								}
							}
							if($#name == 0) {  # There is precisely one optimal:
								$j = $name[0]
							} else {
								push(@name, @namesub);
								if($#name < 0) {  # No name at all:
									$morecand = 1;
									$j = $movecand[0]
								} else {  # Several optimal names or only suboptimal names:
									$morecand = 1;  # We have a warning/error in any case
									$j = $name[0]
								}
							}
						}
					}
					my $g = $B[$j];
					my ($Bname) = @$g;
					if($move) {
						if($morecand) {
							my @err = ("several candidates for moving to $Aname:");
							for my $jt (@movecand) {
								push(@err, &formatnice($B[$jt]))
							}
							if($force) {
								&warning(@err, "\tchosen candidate is $Bname")
							} else {
								&error(@err, "\twith option --force choice would be $Bname");
								$willdie = 1
							}
						}
						&fatal('this error should never occur.',
							'My logic would move the same files several times.',
							'To be on the safe side, I do nothing at all.')
							if(defined($from_name{$Bname}));
						$from_name{$Bname} = $Aname;
						$deleted_index[$j] = 1;
						&make_dirs_for($Aname, '')
					}
					&changemods($Aname, $Amode, $Aowner, $Atime, '', '', $j)
				}
			} else {  # No file with a checksum for $f exists -> No chance to copy it.
				push(@not_exist, $f)
			}
		} else {  # directory, link, or other strange filetype:
			my $tolinkRemember = $tolink; # $tolink is set by &isordinary as a side effect
			if(&isdircheck($Achecksum)) {  # Directory:
				my ($isnew, $j) = &make_dirs_for($Aname, '', 1);
				&changemods($Aname, $Amode, $Aowner, $Atime, '', $isnew, $j)
			} elsif(&isother($Achecksum)) {  # Other strange filetype:
				my ($isnew, $j) = &make_dirs_for($Aname, $Achecksum);
				if($isnew) {
					push(@link_cmds, &shell_dash('touch', $Aname));
					&warning("special type file $Aname created as ordinary file")
				}
				&changemods($Aname, $Amode, $Aowner, $Atime, '', $isnew, $j)
			} else {  # Link:
				my ($isnew, $j) = &make_dirs_for($Aname, $Achecksum);
				push(@link_cmds, &shell_dash(['ln', '-s'], $tolinkRemember, $Aname)) if($isnew);
				&changemods($Aname, $Amode, $Aowner, $Atime, 1, $isnew, $j)
			}
		}
	}

	# Pass 1.5: Create @copy_cmds
	# There are two reasons why the name could have been changed in the meantime:
	# Either the original name (in $B) might have been changed by &make_dirs_for
	# (in case of name collision), or the file should have been moved away.
	# For the first reason, we had to collect the source only in index form.
	for my $a (@copy_list) {
		my $to = $a->[1];
		my $from = &thename($B[$a->[0]]);
		my $froma = ($from_name{$from} // '');
		$from = $froma if($froma ne '');
		push(@copy_cmds, &shell_dash(['cp', '-p', '-i'], $from, $to));
	}

	# Pass 2: We search for the existing files which have not already been moved.
	#         The corresponding delete commands are collected in @del_cmds.
	for my $g (@B) {
		my ($Bname, $Bchecksum, $Bmode, $Bowner, $Btime) = @$g;
		unless(defined($from_name{$Bname})) {
			unless(defined($Afullname{$Bname})) {
				if(&isdircheck($Bchecksum)) {
					unless(defined($needed_dir{$Bname})) {
						push(@rmdir_cmds, ($follow ?
							&shell_quote_best_effort('test', '-h', $Bname)
							. ' && ' .
							&shell_dash('rm', $Bname)
							. ' || ' .
							&shell_dash('rmdir', $Bname)
							:
							&shell_dash('rmdir', $Bname)))
					}
				} elsif($dodelete) {
					push(@del_cmds, &shell_dash('rm', $Bname))
				}
			}
		}
	}

	# Now we prepare the move action (from the index of %from_name to its content)
	# We may not just collect the corresponding 'mv' commands, since loops are
	# not excluded (e.g. if two filenames were swapped).
	for my $p (keys(%from_name)) {
		my $q = $from_name{$p};
		delete($from_name{$p});
		if(defined($q)) {  # We have not moved $p yet.
			my @T = ($p, $q);
			my $loop = '';
			while() {
				my $qold = $q;
				$q = $from_name{$q};
				delete $from_name{$qold};
				last unless(defined($q));  # Our `loop' is no loop: It just has finished
				if($q eq $p) {
					# Our loop has reached the start:
					# At first, we create a temporary filename in the directory of $p
					$loop = 1;
					my $tempname = &mktempname($p);
					# Next, we close the loop over the temporary file:
					push(@T, $tempname);
					unshift(@T, $tempname);
					last
				}
				push(@T, $q)
			}
			my $i = $#T;
			my $to = $T[$i];
			unless($loop) {
				my $g = $Bfullname{$to};
				if(defined($g)) {
					my $checksum = undef;
					if($g ne '') {
						$checksum = &thechecksum($B[$g])
					}
					if(&isdircheck($checksum)) {
						# We should move a file onto a yet existing directory:
						my $tempname = &mktempname($to);
						push(@after_rmdir_cmds, &shell_dash('rmdir', $to));
						push(@after_rmdir_cmds, &shell_dash(['mv', '-i'], $tempname, $to));
						$to = $tempname;
					} elsif(&islinkcheck($checksum)) {
						# We should move a file onto a symbolic link:
						push(@mov_cmds, &shell_quote_best_effort('test', '-h', $to) .
							' && ' . &shell_dash('rm', $to))
					} else {
						# We should move a file onto a file/other which will not be moved:
						if($dodelete) {
							push(@mov_cmds, &shell_dash('rm', $to))
						} elsif(!$force) {
							my $from = $T[$#T - 1];
							&error('you have chosen to not delete any file, but I should',
							"move $from onto $to",
							'Since $to should not be moved somewhere else, this would erase it.',
							'I cannot resolve this conflict, and for this reason, I will do nothing.',
							'Use --force, if you want to get asked during moving.');
							$willdie = 1;
						}
					}
				} else {
					$Bfullname{$to} = ''
				}
				delete($Bfullname{$T[0]})
			}
			while($i > 0) {
				my $from = $T[--$i];
				&fatal('this error should never occur.',
					'My logic would move a file to itself.',
					'To be on the safe side, I do nothing at all.')
					if($from eq $to);
				push(@mov_cmds, &shell_dash(['mv', '-i'], $from, $to));
				$to = $from
			}
		}
	}

	# Now we are done and can actually execute the commands.
	# Before we do so, we reverse the @mod_cmds: In this way, the commands are
	# sorted depth first (more or less), and so the modification times of the
	# directories are preserved as far as possible.
	@mod_cmds = reverse(@mod_cmds);
	# The same holds for the @rmdir_cmds:
	@rmdir_cmds = reverse(sort(@rmdir_cmds));
	# There might be reasons to do nothing:
	$willdie and &fatal('due to earlier errors, I do nothing at all');
	&doexec(\@mkdir_cmds);
	&doexec(\@mov_cmds);
	&doexec(\@copy_cmds);
	&doexec(\@link_cmds);
	&doexec(\@del_cmds);
	&doexec(\@rmdir_cmds);
	&doexec(\@after_rmdir_cmds);
	&doexec(\@mod_cmds);
	if(@not_exist) {
		print("\n\# The following files could not be created by renaming:\n")
			unless($quiet);
		for my $f (@not_exist) {
			print(($quiet ? () : '# '), &formatnice($f), "\n");
		}
	}
}

# This function sets $mode/$owner/$time for $name if appropriate
# (the commands are collected in @mod_cmds).
# Whether this is appropriate depends on the other flags.
# $islink is true iff $name is a symbolic link (which needs other commands).
# If $isnew is false, then only the values differing from $B[$j] are set.
sub changemods {
	my($name, $mode, $owner, $time, $islink, $isnew, $j) = @_;
	if((!$isnew) && (($j // '') ne '')) {
		my $g = $B[$j];
		my ($Bname, $Bchecksum, $Bmode, $Bowner, $Btime) = @$g;
		undef($mode) unless($modattrib && defined($mode) && ($mode ne '') &&
			((!defined($Bmode)) || ($Bmode ne $mode)));
		undef($owner) unless($modowner && defined($owner) && ($owner ne '') &&
			((!defined($Bowner)) || ($Bowner ne $owner)));
		undef($time) unless($modtime && defined($time) && ($time ne '') &&
			((!defined($Btime)) || ($Btime ne $time)))
	} else {
		undef($mode) unless($modattrib && defined($mode) && ($mode ne ''));
		undef($owner) unless($modowner && defined($owner) && ($owner ne ''));
		undef($time) unless($modtime && defined($time) && ($time ne ''))
	}
	if($islink) {
		# chmod and touch have no --no-derefence option and thus are useless
		# to modify a link.
		push(@mod_cmds, &shell_dash(['chown', '-h'], $owner, $name))
			if(defined($owner))
	} else {
		push(@mod_cmds, &shell_dash('chmod', $mode, $name))
			if(defined($mode));
		push(@mod_cmds, &shell_dash('chown', $owner, $name))
			if(defined($owner));
		push(@mod_cmds, &shell_dash(['touch', '--date=' . $time], $name))
			if(defined($time))
	}
}

# This tricky function serves two purposes:
# 1. If the checksum argument is empty, the directories contained
#    in the path of $p are created (if they do not already exist),
#    and these directories are marked in %needed_dir.
#    If the directories overlap with existing files, the original files are
#    renamed to temporary names.
#    All necessary side-effects are done during renaming, too (hopefully).
# 2. If the file $p does not already exist (with $checksum as checksum),
#    then it (and the directories in the path) are virtually created.
#    "virtually" means that no real "creation" action is done, but that
#    the new file is inserted into the list of files. As for 1., if necessary
#    the original file $p is renamed to a temporary filename.
# In both cases, the return value is an array of two entries.
# The first entry is boolean and true iff the (longest) directory resp. file
# had to be created. The second entry contains the index of the found
# respectively newly created index. If no action is to be done for $p$
# (e.g. because $p is empty), then the return value is ('',undef).
sub make_dirs_for {
	my($p, $checksum, $keep) = @_;
	my $defact = '';
	unless(($checksum // '') ne '') {
		$defact = 1;
		unless(($keep // '') ne '') {
			my ($vol, @dir) = &split_dir($p);
			pop(@dir);
			return ('', undef) unless(@dir);
			$p = &cat_dir($vol, @dir)
		}
		$checksum = 'dir'
	}
	my $j = $Bfullname{$p};
	if(defined($j)) {
		my $g = $B[$j];
		my ($Bname, $Bchecksum, $Bmode, $Bowner, $Btime) = @$g;
		$p = $Bname;   # If in doubt, we choose the unique name.
		if($defact) {
			if(&isdircheck($Bchecksum)) {
				&needed_dir_parents($Bname);
				return ('', $j)
			}
		} elsif($Bchecksum eq $checksum) {
			return ('', $j)
		}
		# A directory must be created whose name is already be used by a file/link.
		# We rename the file:
		my $tempname = &mktempname($p);
		push(@mkdir_cmds, &shell_dash(['mv', '-i'], $Bname, $tempname));
		# We remember the new name in our current list of filenames:
		# Make sure that the index number does not change:
		# We need it for $deleted_index and for @copy_list.
		$g->[0] = $tempname;
		$B[$j] = $g;
		$Bfullname{$tempname} = $j; # Remember also in the hash-list.
		# If we already decided to move this file, use the new filename:
		if(defined($from_name{$p})) {
			$from_name{$tempname} = $from_name{$p};
			delete $from_name{$p};
		}
	} elsif($p eq $mdot) {  # The '.' directories need not be created
		return ('', undef)
	}
	# Create a new entry for the directory/file
	push(@B, [$p, $checksum, undef, undef, undef]);
	$j = $#B;
	$Bfullname{$p} = $j;
	$needed_dir{$p} = '' if($defact);
	# First create recursively all required directories, and then $p
	&make_dirs_for($p, '');
	if($defact) {
		$umask //= sprintf('%03o', (0777 ^ umask()));
		push(@mkdir_cmds, &shell_dash(['mkdir', '-m', $umask], $p))
	}
	(1, $j)
}

# Mark the Directory and all its parents as needed:
sub needed_dir_parents {
	for(my ($vol, @dir) = &split_dir($_[0]); @dir; pop(@dir)) {
		$needed_dir{&cat_dir($vol, @dir)} = ''
	}
}

# Create a temporary filename in the directory of $p.
{  my %tempnamelist = ();
sub mktempname {
	my ($vol, $dir, $file) = File::Spec->splitpath(File::Spec->canonpath($_[0]));
	for(my $i = 0; ; ++$i) {
		my $tempname = File::Spec->catpath($vol, $dir, $i . $$ . '.tmp');
		unless(exists($Afullname{$tempname}) ||
			exists($Bfullname{$tempname}) ||
			exists($tempnamelist{$tempname}) ||
			(-e $tempname)) {
			$tempnamelist{$tempname} = '';
			return $tempname
		}
	}
}}

sub isdircheck {
	my ($a) = @_;
	defined($a) && ($a =~ m{^dir$}i)
}

sub isother {
	my ($a) = @_;
	defined($a) && ($a =~ m{^other:}i)
}

sub basename {
	(File::Spec->splitpath($_[0]))[2]
}

# Must set $tolink as a side effect, if file is a link.
sub islinkcheck {
	my ($a) = @_;
	$tolink = '';
	if($a =~ m{\A\s*\-\>\s*(.*)}m) {
		$tolink = $1;
		return 1
	}
	''
}

# Must set $tolink as a side effect, if file is a link.
sub isordinary {
	my ($a) = @_;
	((&isdircheck($a)) || (&isother($a))) ? '' : !&islinkcheck($a)
}

sub doexec {
	my ($a) = @_;
	for my $s (@$a) {
		print($s, "\n") if((!$quiet) || $show);
		system($s) unless($show)
	}
}

sub printdoubles {
	@A = sort { $a->[1] cmp $b->[1] } @A;
	my @finallist = ();
	my @doubles = ();
	my $prevc = 'dir';
	my $prevn = undef;
	for my $f (@A) {
		my ($c, $n) = (&thechecksum($f), &thename($f));
		if(($c eq $prevc) && (&isordinary($f))) {
			push(@doubles, $prevn) unless(@doubles);
			push(@doubles, $n)
		} elsif(@doubles) {
			&pushsorted(\@finallist, \@doubles);
			@doubles = ()
		}
		($prevc, $prevn) = ($c, $n)
	}
	&pushsorted(\@finallist, \@doubles) if(@doubles);
	for my $doublist (sort { $a->[0] cmp $b->[0] } @finallist) {
		print(($quiet ? () : '# Same Checksum: '),
			&list2string(@$doublist), "\n")
	}
}

sub pushsorted {
	my ($dest, $source) = @_;
	my @sorted = sort(@$source);
	push(@$dest, \@sorted)
}

sub thename {
	$_[0]->[0]
}

sub thechecksum {
	$_[0]->[1]
}

sub formatnice {
	my ($f) = @_;
	my ($name, $checksum, $mode, $owner, $time) = @$f;
	&list2string($name, $time // (), $owner // (),
		$mode // (), $checksum // ())
}

}  # Patch

# Parse Options:

Getopt::Long::Configure(qw(gnu_getopt));
Getopt::Long::GetOptions(
	'help|h', sub { &pod2usage(0) },
	'man|?', sub { &pod2usage(-verbose => 2, -exit => 0) },
	'version|V', \&version,
	'show|dry-run|s|n', \$show,
	'delete|d', \$dodelete,
	'nodelete|D', sub { $dodelete = '' },
	'owner|o', \$modowner,
	'noowner|O', sub { $modowner = '' },
	'attrib|a', \$modattrib,
	'noattrib|A', sub { $modattrib = '' },
	'time|t', \$modtime,
	'notime|T', sub { $modtime = '' },
	'copy|z', \$dupcopy,
	'nocopy|Z', sub { $dupcopy = '' },
	'checksum|c', \$calccheck,
	'nochecksum|C', sub { $calccheck = '' },
	'recurse|r', \$recurse,
	'norecurse|R', sub { $recurse = '' },
	'justintime|j', \$justintime,
	'follow-link|F', \$follow,
	'nofollow-link', sub { $follow = '' },
	'upper|u', \$upper,
	'noupper|U', sub { $upper = '' },
	'lower|l', \$lower,
	'nolower|L', sub { $lower = '' },
	'output-strip|P=i', \$outstrip,
	'strip|p=i', \$strip,
	'sum-cmds|S=s', \$sumcmds,
	'file|f=s', \@files,
	'files|i=s', sub { push(@files, $_[1]);
		push(@files, shift(@ARGV)) while(@ARGV && !($ARGV[0] =~ m{^-.})) },
	'hint|h=s', \@hints,
	'hints|I=s', sub { push(@hints, $_[1]);
		push(@hints, shift(@ARGV)) while(@ARGV && !($ARGV[0] =~ m{^-.})) },
	'force', \$force,
	'verbose|v+', \$verbose,
	'quiet|q+', \$quiet,
	'addseconds=i', \$addseconds,
	'subseconds=i', \$subseconds,
	'store', sub { $mode = "store" },
	'restore', sub { $mode = "restore" },
	'double', sub { $mode = "double" }
) or &pod2usage(2);

# Interpreting the parsed values:

@files = split(qr{,}, join(',', @files));
@hints = split(qr{,}, join(',', @hints));

$addseconds -= $subseconds;

if($quiet < $verbose) {
	$verbose -= $quiet;
	$quiet = 0
} else {
	$quiet -= $verbose;
	$verbose = 0
}

# Get mode unless this was specified as an option
unless($mode) {
	$mode = shift(@ARGV);
	&pod2usage('mode must be specified') unless(defined($mode))
}

@sumcmds = split(qr{;}, $sumcmds);
# We do 'use Digest::MD5' at run-time, only if it is needed:
# In this way, the non-existence of this module does not give an error if
# by the options only other checksum-programs are required.
# Since 'use' is executed at compile-time, we have to use 'require' and do the
# import()-initialization by hand.
for my $i (@sumcmds) {
	if($i eq '.') {
		require Digest::MD5;
		last
	}
}

if($mode eq 'store') {
	&standardlist();
	&printlist(\@A);
} elsif($mode eq 'restore') {
	if(@files) {
		&readlist(\@files, \@B, \@Adirs, \%Bfullname);
		&readlist(\@ARGV, \@A, \@Adirs, \%Afullname)
	} else {
		&readlist(\@ARGV, \@A, \@Adirs, \%Afullname);
		if($strip > 0) {
			@Adirs = ($mdot);
			$strip = 0
		}
		&makelist(\@B, \%Bfullname, \@Adirs)
	}
	&make_check(\@B, \%Bcheck);
	&patchlist()
} elsif($mode eq 'double') {
	&standardlist();
	&printdoubles()
} else {
	&pod2usage('no mode specified')
}
